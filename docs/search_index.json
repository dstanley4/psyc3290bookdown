[["index.html", "Welcome! Course:", " Welcome! David J. Stanley 2020-12-13 Course: These notes are a resource for students in my PSYC 3290 class. "],["about-the-author.html", "About the Author", " About the Author David J. Stanley is an Associate Professor of Industrial and Organizational Psychology at the University of Guelph in Canada. He obtained his PhD from Western University in London, Ontario. David has published articles in Advances in Methods and Practices in Psychological Science, Organizational Research Methods, Journal of Applied Psychology, Perspectives in Psychological Science, Journal of Business and Psychology, Journal of Vocational Behaviour, Journal of Personality and Social Psychology, Behavior Research Methods, Industrial and Organizational Psychology, and Emotion among other journals. David also created the apaTables R package. "],["introduction.html", "Chapter 1 Introduction 1.1 A focus on workflow 1.2 R works with plug-ins 1.3 Create an account at R Studio Cloud 1.4 Join the class workspace 1.5 Exploring the R Studio Interface 1.6 Writing your first script 1.7 Loading your data 1.8 Checking out your data 1.9 Run vs. Source with Echo vs. Source 1.10 Trying Source with Echo 1.11 A few key points about 1.12 That’s it!", " Chapter 1 Introduction Welcome! In this guide, we will teach you about statistics using the statistical software R with the interface provided by R Studio. The purpose of this chapter to is provide you with a set of activities that get you up-and-running in R quickly so get a sense of how it works. In later chatpers we will revisit these same topics in more detail. 1.1 A focus on workflow An important part of this guide is training you in a workflow that will avoid many problems than can occur when using R. 1.2 R works with plug-ins R is a statistical language with many plug-ins called packages that you will use for analyses. You can think of R as being like your smartphone. To do things with your phone you need an App (R equivalent: a package) from the App Store (R equivalent: CRAN). Apps need to be downloaded (R equivalent: install.packages) before you can use them. To use the app you need Open it (R equivalent: library command). These similarities are illustrated in Table 1.1 below. TABLE 1.1: R packages are similar to smart phone apps (Kim, 2018) Smart Phone Terminology R Terminology App package App Store CRAN Download App from App Store install.packages(“apaTables”, dependencies = TRUE) Open App library(“apaTables”) 1.3 Create an account at R Studio Cloud R Studio Cloud accounts are free and required for this guide. Please go to the website and set up a new account. 1.4 Join the class workspace To do the assignment required for this class you need to join the class workspace on R Studio Cloud. To do so: Log into R Studio Cloud (if you haven’t already done so). Go to your university email account and find the message with the subject “R Studio Workspace Invitation”. In this message there is a link to the class R Studio Cloud workspace. Click on the workspace link in the email or paste it into your web browser. You should see a screen like the one below in Figure 1.1. Click on the Join button. FIGURE 1.1: Screenshot of workspace join message Then you should see the welcome message illustrated in Figure 1.2. Above this message is the Projects menu option. Click on the word Project. FIGURE 1.2: Screenshot of welcome message You should now see the First Project displayed as in 1.3. Click the Start button. You will then move to a view of R Studio. FIGURE 1.3: Screenshot of starting first assignment In R Studio it is essential you use projects to keep your files organized and in the same spot. For this course, when your start an assignment on R Studio Cloud and the project will already have been made for you. Later you will learn to make your own R Studio Projects. 1.5 Exploring the R Studio Interface Once you have opened (or created) a Project folder, you are presented with the R Studio interface. There are a few key elements to the user interface that are illustrated in Figure 1.4 In the lower right of the screen you can see the a panel with several tabs (i.e., Files, Plots, Packages, etc) that I will refer to as the Files pane. You look in this pane to see all the files associated with your project. On the left side of the screen is the Console which is an interactive pane where you type and obtain results in real time. I’ve placed two large grey blocks on the screen with text to more clearly identify the Console and Files panes. Not shown in this figure is the Script panel where we can store our commands for later reuse. FIGURE 1.4: R Studio interface 1.5.1 Console panel When you first start R, the Console panel is on the left side of the screen. Sometimes there are two panels on the left side (one above the other); if so, the Console panel is the lower one (and labeled accordingly). We can use R a bit like a calculator. Try typing the following into the Console window: 8 + 6 + 7 + 5. You can see that R immediately produced the result on a line preceded by two hashtags (##). 8 + 6 + 7 + 5 ## [1] 26 We can also put the result into a variable to store it. Later we can use the print command to see that result. In the example below we add the numbers 3, 0, and 9 and store the result in the variable my_sum. The text “&lt;-” indicate you are putting what is on the right side of the arrow into the variable on the left side of the arrow. You can think of a variable as cup into which you can put different things. In this case, imagine a real-world cup with my_sum written on the outside and inside the cup we have stored the sum of 3, 0, and 9 (i.e., 12). my_sum &lt;- 3 + 0 + 9 We can inspect the contents of the my_sum variable (i.e., my_sum cup) with the print command: print(my_sum) ## [1] 12 Variable are very useful in R. We will use them to store a single number, an entire data set, the results of an analysis, or anything else. 1.5.2 Script Panel Although you can use R with just with the Console panel, it’s a better idea to use scripts via the Script panel - not visible yet. Scripts are just text files with the commands you use stored in them. You can run a script (as you will see below) using the Run or Source buttons located in the top right of the Script panel. Scripts are valuable because if you need to run an analysis a second time you don’t have to type the command in a second time. You can run the script again and again without retyping your commands. More importantly though, the script provides a record of your analyses. A common problem in science is that after an article is published, the authors can’t reproduce the numbers in the paper. You can read more about the important problem in a surprising article in the journal Molecular Brain. In this article an editor reports how a request for the data underlying articles resulted in the wrong data for 40 out of 41 papers. Long story short – keep track of the data and scripts you use for your paper. In a later chapter, it’s generally poor practice to manipulate or modify or analyze your data using any menu driven software because this approach does not provide a record of what you have done. 1.6 Writing your first script 1.6.1 Create the script file Create a script in your R Studio project by using the menu File &gt; New File &gt; R Script. Save the file with an appropriate name using the File menu. The file will be saved in your Project folder. A common, and good, convention for naming is to start all script names with the word “script” and separate words with an underscore. You might save this first script file with the name “script_my_first_one.R”. The advantage of beginning all script files with the word script is that when you look at your list of files alphabetically, all the script files will cluster together. Likewise, it’s a good idea to save all data files such that they begin with “data_”. This way all the data files will cluster together in your directory view as well. You can see there is already a data file with this convention called “data_okcupid.csv”. You can see as discussed previously, we are trying to instill an effective workflow as you learn R. Using a good naming convention (that is consistent with what others use) is part of the workflow. When you write your scripts it’s a good idea to follow the tidyverse style guide for script names, variable name, file names, and more. 1.6.2 Add a comment to your script In the previous section you created your first script. We begin by adding a comment to the script. A comment is something that will be read by humans rather than the computer/R. You make comments for other people that will read your code and need to understand what you have done. However, realize that you are also making comments for your future self as illustrated in an XKCD cartoon. A good way to start every script is with a comment that includes the date of your script (or even better when you installed your packages, more on this later). Like smartphone apps, packages are updated regularly. Sometimes after a package is updated it will no longer work with an older script. Fortunately, the checkpoint package lets users role back the clock and use older versions of packages. Adding a comment with the date of your script will help future users (including you) to use your script with the same version of the package used when you wrote the script. Dating your script is an important part of an effective and reproducible workflow. # Code written on: YYYY/MM/DD # By: John Smith Moving forward, I suggest you use comments to make your own personal notes in your own code as your write it. Note that in the above comment I used the internationally accepted date format order Year/Month/Day created by the International Organization for Standardization (ISO). Some people use the mnemonic Your My Dream to remember the Year Month Day order. Wikipedia provides more information about this International Date Format (ISO 8601). An XKCD cartoon highlights the ISO date format: 1.6.3 Background about the tidyverse There are generally two broad ways of using R, the older way and the newer way. Using R the older way is refered to as using base R. A more modern approach to using R is the tidyverse. The tidyverse represents a collection of packages the work together to give R a modern workflow. These packages do many things to help the data analyst (loading data, rearranging data, graphing, etc.). We will use the tidyverse approach to R in this guide. A noted the tidyverse is a collection of packges. Each package adds new commands to R. The number of packges and correspondingly the number of new commands added to R by the tidyverse is large. Below is a list of the tidyverse packages: ## [1] &quot;broom&quot; &quot;cli&quot; &quot;crayon&quot; &quot;dbplyr&quot; ## [5] &quot;dplyr&quot; &quot;forcats&quot; &quot;ggplot2&quot; &quot;haven&quot; ## [9] &quot;hms&quot; &quot;httr&quot; &quot;jsonlite&quot; &quot;lubridate&quot; ## [13] &quot;magrittr&quot; &quot;modelr&quot; &quot;pillar&quot; &quot;purrr&quot; ## [17] &quot;readr&quot; &quot;readxl&quot; &quot;reprex&quot; &quot;rlang&quot; ## [21] &quot;rstudioapi&quot; &quot;rvest&quot; &quot;stringr&quot; &quot;tibble&quot; ## [25] &quot;tidyr&quot; &quot;xml2&quot; &quot;tidyverse&quot; Before you can use a package it needs to be installed – this is the same as downloading an app from the App Store. Normally, you can install a single packages with the install.packages command. Previously, you needed run an install.package command for every package in the tidyverse as illustrated below (though we no longer use this approach). # The old way of installing the tidyverse packages # Like downloading apps from the app store install.packages(&quot;broom&quot;, dep = TRUE) install.packages(&quot;cli&quot;, dep = TRUE) install.packages(&quot;ggplot&quot;, dep = TRUE) # etc Fortunately, the tidyverse packages can now by installed with a single install.packages command. Specifically, the install.packages command below will install all of the packages listed above. Class note: For the “First Lab”, I’ve done the install.packages for you. So there is no need to use the install.packages command below in this first lab. install.packages(&quot;tidyverse&quot;, dep = TRUE) 1.6.4 Add library(tidyverse) to your script The tidyverse is now installed, so we need to activate it. We do that with the library command. Put the library line below at the top of your script file (below your comment): # Code written on: YYYY/MM/DD # By: John Smith library(tidyverse) 1.6.5 Activate tidyverse auto-complete for your script Select the library(tidyverse) text with your mouse/track-pad so that it is highlighted. Then click the Run button in the upper right of the Script panel. Doing this “runs” the selected text. After you click the Run button you should see text like the following the Console panel: ## ── Attaching packages ─────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ## ✓ tibble 3.0.4 ✓ dplyr 1.0.2 ## ✓ tidyr 1.1.2 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.0 ## ── Conflicts ────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() When you use library(tidyverse) to activate the tidyverse you activate the most commonly used subset of the tidyverse packages. In the output you see checkmarks beside names of the tidyverse packages you have activated. By activating these packages you have added new commands to R that you will use. Sometimes these packages replace older versions of commands in R. The “Conflicts” section in the output shows you where the packages you activated replaced older R commands with newer R commands. You can activate the other tidyverse package by running a library command for each package – if needed. No need to do so now. Most importantly, running the library(tidyverse) prior to entering the rest of your script allows R Studio to present auto-complete options when typing your text. Remember to start each script with the library(tidyverse) command and then Run it so you get the autocomplete options for the rest of the commands your enter. 1.7 Loading your data 1.7.1 Use read_csv (not read.csv) to open files. If you inspect the Files pane on the right of the screen you see the data_okcupid.csv data file in our project directory. We will load this data with the commands below. If you followed the steps above, you should have auto-complete for the tidyverse commands you type for now in – in the current R session. Enter the command below into your script. As your start to type read_csv you will likely be presented with an auto-complete option. You can use the arrow keys to move up and down the list of options to select the one you want - then press tab to select it. Once your command looks like the one below select the text and click on the “Run” button. Note: If you are not in the class, the data file is available from: https://github.com/dstanley4/psyc3250bookdown okcupid_profiles &lt;- read_csv(file = &quot;data_okcupid.csv&quot;) ## ## ── Column specification ──────────────────────────────────── ## cols( ## age = col_double(), ## diet = col_character(), ## height = col_double(), ## pets = col_character(), ## sex = col_character(), ## status = col_character() ## ) The output indicates that you have loaded a data file and the type of data in each column. The sex column is of type col_character which indicates it contains text/letters. Most of the columns are of the type character. The age and height columns contain numbers are correspondingly indicated to be the type col_double. The label col_double indicates that a column of numbers represented in R with high precision. There are other ways of representing numbers in R but this is the type we will see/use most often. 1.8 Checking out your data There many ways of viewing the actual data you loaded. A few of these are illustrated now. 1.8.1 view(): See a spreadsheet view of your data You can inspect your data in a spreadsheet view by using the view command. Do NOT add this command to your script file – EVER. Adding it to the script can cause substantial problems. Type this command in the Console. view(okcupid_profiles) 1.8.2 print(): See you data in the Console You can inspect the first few rows of your data with the print() command. It is OK to add a print command to your script. Try the print() command below in the Console: print(okcupid_profiles) ## # A tibble: 59,946 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly an… 75 likes dogs and l… m single ## 2 35 mostly other 70 likes dogs and l… m single ## 3 38 anything 68 has cats m availa… ## 4 23 vegetarian 71 likes cats m single ## 5 29 &lt;NA&gt; 66 likes dogs and l… m single ## 6 29 mostly anyt… 67 likes cats m single ## 7 32 strictly an… 65 likes dogs and l… f single ## 8 31 mostly anyt… 65 likes dogs and l… f single ## 9 24 strictly an… 67 likes dogs and l… f single ## 10 37 mostly anyt… 65 likes dogs and l… m single ## # … with 59,936 more rows 1.8.3 head(): Check out the first few rows of data You can inspect the first few rows of your data with the head() command. Try the command below in the Console: head(okcupid_profiles) ## # A tibble: 6 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly any… 75 likes dogs and l… m single ## 2 35 mostly other 70 likes dogs and l… m single ## 3 38 anything 68 has cats m availa… ## 4 23 vegetarian 71 likes cats m single ## 5 29 &lt;NA&gt; 66 likes dogs and l… m single ## 6 29 mostly anyth… 67 likes cats m single You can be even more specific and indicate you only want the first three row of your data with the head() command. Try the command below in the Console: head(okcupid_profiles, 3) ## # A tibble: 3 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly any… 75 likes dogs and l… m single ## 2 35 mostly other 70 likes dogs and l… m single ## 3 38 anything 68 has cats m availa… 1.8.4 tail(): Check out the last few rows of data You can inspect the last few rows of your data with the tail() command. Try the command below in the Console: tail(okcupid_profiles) ## # A tibble: 6 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 31 &lt;NA&gt; 62 likes dogs f single ## 2 59 &lt;NA&gt; 62 has dogs f single ## 3 24 mostly anyt… 72 likes dogs and lik… m single ## 4 42 mostly anyt… 71 &lt;NA&gt; m single ## 5 27 mostly anyt… 73 likes dogs and lik… m single ## 6 39 &lt;NA&gt; 68 likes dogs and lik… m single You can be even more specific and indicate you only want the last three row of your data with the tail() command. Try the command below in the Console: tail(okcupid_profiles, 3) ## # A tibble: 3 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 42 mostly anyt… 71 &lt;NA&gt; m single ## 2 27 mostly anyt… 73 likes dogs and lik… m single ## 3 39 &lt;NA&gt; 68 likes dogs and lik… m single 1.8.5 summary(): Quick summaries You can a short summary of your data with the summary() command. Note that we will use the summary() command in many places in the guide. The output of the summary() command changes depending on what you give it - that is put inside the brackets. You can give the summary() command many things such as data, the results of a regression analysis, etc. Try the command below in the Console. You will see that summary() give the mean and median for each of the numeric variables (age and height). summary(okcupid_profiles) ## age diet height ## Min. : 18.0 Length:59946 Min. : 1.0 ## 1st Qu.: 26.0 Class :character 1st Qu.:66.0 ## Median : 30.0 Mode :character Median :68.0 ## Mean : 32.3 Mean :68.3 ## 3rd Qu.: 37.0 3rd Qu.:71.0 ## Max. :110.0 Max. :95.0 ## NA&#39;s :3 ## pets sex status ## Length:59946 Length:59946 Length:59946 ## Class :character Class :character Class :character ## Mode :character Mode :character Mode :character ## ## ## ## 1.9 Run vs. Source with Echo vs. Source There are different ways of running commands in R. So far you have used two of these. You can enter them into the Console as we have done already. Or you can put them in your script select the text and clickk the Run button. There are four ways of running commands in your script. You can: Console: Enter commands directly Script: Select the command(s) and press the Run button. Script: Source (Without Echo) Script: Source With Echo Two of these approaches involve using the Source button, see Figure 1.5. You bring up the options for the Source button, illustrated in this figure, by clicking on the small arrow to the right of the word Source. FIGURE 1.5: Source button options 1.9.1 Run select text The Run button will run the text you highlight and present the relevant output. You have used this command a fair amount already. I strongly suggest you ONLY use the Run button when testing a command to make sure it works or to debug a script. Or to run library(tidyverse) as you start working on your script so that you get the autocomplete options. In general, you should always try to execute your R Scripts using the Source with Echo command (preceded by a Restart, see below). This ensures your script will work beginning to end for you in the future and for others that attempt to use it. Using the Run button in an ad lib basis can create output that is not reproducible. 1.9.2 Source (without Echo) Source (without Echo) is not designed for the typical analysis workflow. It is mostly helpful when you run simulations. When you run Source (without Echo) much of the output you would wish to read is suppressed. In general, avoid this option. If you use it, you often won’t see what you want to see in the output. 1.9.3 Source with Echo The Source with Echo command runs all of the contents of a script and presents the output in the R console. This is the approach you should use to running your scripts in most cases. Prior to running Source with Echo (or just Source), it’s always a good idea to restart R. This makes sure you clear the computer memory of any errors from any previous runs. So you should do the following EVERY time you run your script. Use the menu item: Session &gt; Restart R Click the down arrow beside the Source button, and click on Source With Echo This will clear potentially problematic previous stats, run the script commands, and display the output in the Console. Moving forward we will use this approach for running scripts. Once you have used Source wiht Echo once, you can just click the Source button and it will use Source with Echo automatically (without the need to use the pull down option for selecting Source with Echo). Using Restart R before you run a script, or R code in general, is a critical workflow tip. 1.10 Trying Source with Echo Put the head(), tail(), and summary() command we used previously into your script. Then save your script using using the File &gt; Save menu. You script should appear as below. # Code written on: YYYY/MM/DD # By: John Smith library(tidyverse) okcupid_profiles &lt;- read_csv(file = &quot;data_okcupid.csv&quot;) head(okcupid_profiles) tail(okcupid_profiles) summary(okcupid_profiles) Now do the following: Use the menu item: Session &gt; Restart R Click the down arrow beside the Source button, and click on Source With Echo You should see the output below: # Code written on: YYYY/MM/DD # By: John Smith library(tidyverse) okcupid_profiles &lt;- read_csv(file = &quot;data_okcupid.csv&quot;) ## ## ── Column specification ──────────────────────────────────── ## cols( ## age = col_double(), ## diet = col_character(), ## height = col_double(), ## pets = col_character(), ## sex = col_character(), ## status = col_character() ## ) head(okcupid_profiles) ## # A tibble: 6 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly any… 75 likes dogs and l… m single ## 2 35 mostly other 70 likes dogs and l… m single ## 3 38 anything 68 has cats m availa… ## 4 23 vegetarian 71 likes cats m single ## 5 29 &lt;NA&gt; 66 likes dogs and l… m single ## 6 29 mostly anyth… 67 likes cats m single tail(okcupid_profiles) ## # A tibble: 6 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 31 &lt;NA&gt; 62 likes dogs f single ## 2 59 &lt;NA&gt; 62 has dogs f single ## 3 24 mostly anyt… 72 likes dogs and lik… m single ## 4 42 mostly anyt… 71 &lt;NA&gt; m single ## 5 27 mostly anyt… 73 likes dogs and lik… m single ## 6 39 &lt;NA&gt; 68 likes dogs and lik… m single summary(okcupid_profiles) ## age diet height ## Min. : 18.0 Length:59946 Min. : 1.0 ## 1st Qu.: 26.0 Class :character 1st Qu.:66.0 ## Median : 30.0 Mode :character Median :68.0 ## Mean : 32.3 Mean :68.3 ## 3rd Qu.: 37.0 3rd Qu.:71.0 ## Max. :110.0 Max. :95.0 ## NA&#39;s :3 ## pets sex status ## Length:59946 Length:59946 Length:59946 ## Class :character Class :character Class :character ## Mode :character Mode :character Mode :character ## ## ## ## Congratulations you just ran your first script! 1.11 A few key points about Sometimes you will need to send a command additional information. Moreover, that information often needs to be grouped together into a vector or a list before you can send it to the command. We’ll learn more about doing so in the future but here is a quick over view of vectors and lists to provide a foundation for future chapters. 1.11.0.1 Vector of numbers We can create a vector of only numbers using the “c” function - which you can think of as being short for “combine” (or concatenate). In the commands below we create a vector of a few even numbers called “even_numbers”. even_numbers &lt;- c(2, 4, 6, 8, 10) print(even_numbers) ## [1] 2 4 6 8 10 We can obtain the second number in the vector using the following notation: print(even_numbers[2]) ## [1] 4 1.11.0.2 Vector of characters We can also create vectors using only characters. Note that I use SHIFT RETURN after each comma to move to the next line. favourite_things &lt;- c(&quot;copper kettles&quot;, &quot;woolen mittens&quot;, &quot;brown paper packages&quot;) print(favourite_things) ## [1] &quot;copper kettles&quot; &quot;woolen mittens&quot; ## [3] &quot;brown paper packages&quot; As before, can obtain the second item in the vector using the following notation: print(favourite_things[2]) ## [1] &quot;woolen mittens&quot; 1.11.1 Lists Lists are similar to vectors in that you can create them and access items by their numeric position. Vectors must be all characters or all numbers. Lists can be a mix of characters or numbers. Most importantly items in lists can be accessed by their label. Note that I use SHIFT RETURN after each comma to move to the next line in the code below. my_list &lt;- list(last_name = &quot;Smith&quot;, first_name = &quot;John&quot;, office_number = 1913) print(my_list) ## $last_name ## [1] &quot;Smith&quot; ## ## $first_name ## [1] &quot;John&quot; ## ## $office_number ## [1] 1913 You can access an item in a list using double brackets: print(my_list[2]) ## $first_name ## [1] &quot;John&quot; You can access an item in a list by its label/name using the dollar sign: print(my_list$last_name) ## [1] &quot;Smith&quot; print(my_list$office_number) ## [1] 1913 1.12 That’s it! Congratulations! You’ve reached the end of the introduction to R. Take a break, have a cookie, and read some more about R tomorrow! "],["handling-data-with-the-tidyverse.html", "Chapter 2 Handling Data with the Tidyverse 2.1 Required 2.2 Objective 2.3 Using the Console 2.4 Basic tidyverse commands 2.5 Advanced tidyverse commands 2.6 Using help 2.7 Base R vs tidyverse", " Chapter 2 Handling Data with the Tidyverse 2.1 Required The data files below are used in this chapter. The files are available at: https://github.com/dstanley4/psyc3250bookdown Required Data data_okcupid.csv data_experiment.csv The following CRAN packages must be installed: Required CRAN Packages tidyverse 2.2 Objective The objective of this chapter is to familiarize you with some key commands in the tidyverse. These commands are used in isolation of each other for the most part. In the next chapter we will use these commands in a more coordinated way as we load a data set and move it from raw data to data that is ready for analysis (i.e., analytic data). You can start this project by Starting the class assignment on R Studio Cloud that corresponds to the chapter name. 2.3 Using the Console All of the commands in this chapter should be typed into the Console within R. If you see a command split over multiple lines, use SHIFT-RETURN (macOS) or SHIFT-ENTER (Windows) to move the next line that is part of the same command. 2.4 Basic tidyverse commands If you inspect the Files tab on the lower-right panel in R Studio you will see the file data_okcupid.csv. The code below loads that file. library(tidyverse) okcupid_profiles &lt;- read_csv(&quot;data_okcupid.csv&quot;) You can see the first few rows of the data using the print() command. Each row presents a person whereas each column represents a variable. If you have a large number of columns you will only see the first several columns with this approach to viewing your data. print(okcupid_profiles) ## # A tibble: 59,946 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly an… 75 likes dogs and l… m single ## 2 35 mostly other 70 likes dogs and l… m single ## 3 38 anything 68 has cats m availa… ## 4 23 vegetarian 71 likes cats m single ## 5 29 &lt;NA&gt; 66 likes dogs and l… m single ## 6 29 mostly anyt… 67 likes cats m single ## 7 32 strictly an… 65 likes dogs and l… f single ## 8 31 mostly anyt… 65 likes dogs and l… f single ## 9 24 strictly an… 67 likes dogs and l… f single ## 10 37 mostly anyt… 65 likes dogs and l… m single ## # … with 59,936 more rows But it’s also helpful just to see a list of the columns in the data with the glimpse() command: glimpse(okcupid_profiles) ## Rows: 59,946 ## Columns: 6 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 32, 31, 24, 37, 35… ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anyt… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 65, 67, 65, 70… ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs a… ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;,… The glimpse() command is useful because it quickly allows you to see all of the columns. Moreover, it allows you to see the type for each column. Types were briefly discussed in the last chapter. Notice in the output beside each column name that some columns are labeled “dbl” which is short for double – a type of numeric column. Other columns are labeled “chr” which is short for character - meaning the columns contain characters. These designations will become important in the next chapter as we prepare data for analysis. 2.4.1 select() The select() command allows you to obtain a subset of the columns in your data. The commands below can be used to obtain the age and height columns. You can read the command as: take the okcupid_profiles data and then select the age and height columns. The “%&gt;%” symbol can be read as “and then”. You can see that this code prints out the data with just the age and height columns. Remember, use SHIFT-ENTER or SHIFT-RETURN to move to the next line in the block of code. okcupid_profiles %&gt;% select(age, height) ## # A tibble: 59,946 x 2 ## age height ## &lt;dbl&gt; &lt;dbl&gt; ## 1 22 75 ## 2 35 70 ## 3 38 68 ## 4 23 71 ## 5 29 66 ## 6 29 67 ## 7 32 65 ## 8 31 65 ## 9 24 67 ## 10 37 65 ## # … with 59,936 more rows Of course, it’s usually of little help to just print the subset of the data. It’s better to store it in a new data. In the command below we store the resulting data in a new data set called new_data. new_data &lt;- okcupid_profiles %&gt;% select(age, height) The glimpse() command shows us that only the age and height columns are in new_data. glimpse(new_data) ## Rows: 59,946 ## Columns: 2 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 32, 31, 24, 37, 35… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 65, 67, 65, 70… In the above example we indicated the columns we wanted to retain from the okcupid_profiles data using the select() command. However, we can also indicate the columns we want to drop from okcupid_profiles using a minus sign (-) in front of the columns we specify in the select() command. new_data &lt;- okcupid_profiles %&gt;% select(-age, -height) The glimpse() command shows us that we kept all the columns except the age and height columns when we created new_data. glimpse(new_data) ## Rows: 59,946 ## Columns: 4 ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anyt… ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs a… ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;,… 2.4.2 summarise() The summarise() command can be used to generate descriptive statistics for a specified column. You can easily calculate column descriptive statistics using the corresponding commands for mean(), sd(), min(), max(), among others. In the example below we calculate the mean for the age column. In the code below, mean(age, na.rm = TRUE), indicates to R that it should calculate the mean of the age column. The na.rm indicates how missing values should be handled. The na stands for not available; in R missing values are classified as Not Available or NA. The rm stands for remove. Consequently, na.rm is asking: “Should we remove missing values when calculating the mean?” The TRUE indicates that yes, missing values should be removed when calculating the mean. The result of this calculation is placed into a variable labelled age_mean, though we could have used any label we wanted instead of age_mean. We see that the mean of the age column is, with rounding, 32.3. okcupid_profiles %&gt;% summarise(age_mean = mean(age, na.rm = TRUE)) ## # A tibble: 1 x 1 ## age_mean ## &lt;dbl&gt; ## 1 32.3 More than one calculation can occur in the same summarise() command. You can easily add the calculation for the standared deviation with the sd() command. okcupid_profiles %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE)) ## # A tibble: 1 x 2 ## age_mean age_sd ## &lt;dbl&gt; &lt;dbl&gt; ## 1 32.3 9.45 Often this process does too much rounding. We can get more exact results by adding an as.data.frame() to the end of the commands. okcupid_profiles %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE)) %&gt;% as.data.frame() ## age_mean age_sd ## 1 32.34 9.453 2.4.3 filter() The filter() command allows you to obtain a subset of the rows in your data. In the example below we create a new data set with just the males from the original data. Notice the structure of the original data below in the glimpse() output. There is a column called sex that uses m and f to indicate male and female, respectively. Also notice that there are 59946 rows in the okcupid_profiles data. glimpse(okcupid_profiles) ## Rows: 59,946 ## Columns: 6 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 32, 31, 24, 37, 35… ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anyt… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 65, 67, 65, 70… ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs a… ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;f… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;,… We use the filter command to select a subset of the rows based on the content of any column. In this case the sex column is used to obtain a subset of the rows; the rows with the value “m” are obtained. Notice the double equals sign is used to indicate “equal to”. The reason a double equals sign is used here (instead of a single equals sign) is to distinguish it from the use of the single equals sign in the summarise command above. In the summarise command above, the single equal sign was used to indicate “assign to”. That is, assign to age_mean the mean of the column age after it is calculated. A single equals sign indicates “assign to” whereas a double equals sign indicates “is equal to”. okcupid_males &lt;- okcupid_profiles %&gt;% filter(sex == &quot;m&quot;) We use glimpse() to inspect these all male data. Notice that only the letter m is in the sex column - indicating only males are in the data set. Also notice that there are 35829 rows in the okcupid_males data - fewer people because males are a subset of the total number of rows. glimpse(okcupid_males) ## Rows: 35,829 ## Columns: 6 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 37, 35, 28, 24, 33… ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;, &quot;anyt… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 70, 72, 72, 70… ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes dogs a… ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;single&quot;,… The filter command can be combined with the summarise command to get the descriptive statistics for males without the hassle of creating new data. This is again done using the %&gt;% “and then” operator. okcupid_profiles %&gt;% filter(sex == &quot;m&quot;) %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE)) ## # A tibble: 1 x 2 ## age_mean age_sd ## &lt;dbl&gt; &lt;dbl&gt; ## 1 32.0 9.03 We see that for the 35829 females the mean age is 32.0 and the standard deviation is 9.0. Likewise, we can obtain the descriptive statistics for females with only a slight modification, changing m to f in the filter command: okcupid_profiles %&gt;% filter(sex == &quot;f&quot;) %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE)) ## # A tibble: 1 x 2 ## age_mean age_sd ## &lt;dbl&gt; &lt;dbl&gt; ## 1 32.8 10.0 We see that for the 24117 females the mean age is 32.8 and the standard deviation is 10.0. 2.4.4 group_by() The process we used with the filter command would quickly become onerous if we had many subgroups for a column. Consequently, it’s often better to use the group() command to calculate descriptive statistics for the levels (e.g., male/female) of a variable. By telling the computer to group_by() sex the summarise command is run separately for every level of sex (i.e., m and f). okcupid_profiles %&gt;% group_by(sex) %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 2 x 3 ## sex age_mean age_sd ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 f 32.8 10.0 ## 2 m 32.0 9.03 Fortunately, it’s possible to use more than one grouping variable with the group_by() command. In the code below we group by sex and status (i.e., dating status). okcupid_profiles %&gt;% group_by(sex, status) %&gt;% summarise(age_mean = mean(age, na.rm = TRUE), age_sd = sd(age, na.rm = TRUE)) ## `summarise()` regrouping output by &#39;sex&#39; (override with `.groups` argument) ## # A tibble: 10 x 4 ## # Groups: sex [2] ## sex status age_mean age_sd ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 f available 32.2 8.54 ## 2 f married 33.7 8.13 ## 3 f seeing someone 28.1 6.44 ## 4 f single 33.0 10.2 ## 5 f unknown 27.8 5.91 ## 6 m available 34.8 9.40 ## 7 m married 38.7 10.1 ## 8 m seeing someone 30.8 7.06 ## 9 m single 31.9 9.04 ## 10 m unknown 40.7 8.87 The resulting output provide for age the mean and standard deviation for every combination of sex and dating status. The first five rows provide output for females at every level of dating status whereas the subsequent five rows provide output for males at every level of dating status. 2.4.5 mutate() The mutate() command can be used to calculate a new column in a data. In the example below we calculate a new column called age_centered which is the new version of the age_column where the mean of the column has been removed from every value. This is merely an example of the many different types of calculations we can perform to create a new column using mutate(). okcupid_profiles &lt;- okcupid_profiles %&gt;% mutate(age_centered = age - mean(age, na.rm = TRUE)) Notice that the glimpse() command reveals that after we use the mutate() command there is a new column called age_centered. glimpse(okcupid_profiles) ## Rows: 59,946 ## Columns: 7 ## $ age &lt;dbl&gt; 22, 35, 38, 23, 29, 29, 32, 31, 24, … ## $ diet &lt;chr&gt; &quot;strictly anything&quot;, &quot;mostly other&quot;,… ## $ height &lt;dbl&gt; 75, 70, 68, 71, 66, 67, 65, 65, 67, … ## $ pets &lt;chr&gt; &quot;likes dogs and likes cats&quot;, &quot;likes … ## $ sex &lt;chr&gt; &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;… ## $ status &lt;chr&gt; &quot;single&quot;, &quot;single&quot;, &quot;available&quot;, &quot;si… ## $ age_centered &lt;dbl&gt; -10.3403, 2.6597, 5.6597, -9.3403, -… 2.5 Advanced tidyverse commands In this advanced selection we revisit the commands from the basic tidyverse section but use more complicated code to either select or apply an action to more than one column at a time. We will indicate the columns that we want to select or apply an action to using: starts_with(), ends_with(), contains(), matches(), or where(). The first four of these are used to indicate columns based on column names. In contrast, the last command, where(), is used to indicate the columns based on the column type (numeric, character, factor, etc.). We will review all five commands for indicating the columns we want in the select() selection below. Following that we will, for brevity, typically use only one of the five commands when illustrating how they work with summarise() and mutate(). We begin by loading a new data. library(tidyverse) data_exp &lt;- read_csv(&quot;data_experiment.csv&quot;) ## ## ── Column specification ──────────────────────────────────── ## cols( ## id = col_double(), ## sex = col_character(), ## t1_vomit = col_double(), ## t1_aggression = col_double(), ## t2_vomit = col_double(), ## t2_aggression = col_double() ## ) The glimpse() command reveals that this is a small data set where every row represents one rat. The sex of the rat is recorded as well as, for each of two time points, a rating of vomiting and aggression. glimpse(data_exp) ## Rows: 6 ## Columns: 6 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,… ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 2.5.1 select() 2.5.1.1 select() using column name 2.5.1.1.1 starts_with() starts_with() allows us to select columns based on how the column name begins. Here we put the columns that begin with “t1” into a new data called data_time1. data_time1 &lt;- data_exp %&gt;% select(starts_with(&quot;t1&quot;)) The glimpse command shows us the new data only contains the columns that begin with “t1” glimpse(data_time1) ## Rows: 6 ## Columns: 2 ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 2.5.1.1.2 ends_with() ends_with() allows us to select columns based on how the column name ends. Here we put the columns that end with “aggression” into a new data set called data_aggression. data_aggression &lt;- data_exp %&gt;% select(ends_with(&quot;aggression&quot;)) glimpse(data_aggression) ## Rows: 6 ## Columns: 2 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ t2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 2.5.1.1.3 contains() contains() allows us to select columns based on the contents of the column name. Here we put the columns that have \"_\" in the name into a new data set called new_data. new_data &lt;- data_exp %&gt;% select(contains(&quot;_&quot;)) glimpse(new_data) ## Rows: 6 ## Columns: 4 ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 2.5.1.1.4 matches() It’s also possible to use regex (regular expressiona) to select columns. Regex is a powerful way to specify search/matching requirements for text - in this case the text of column names. An explanation of regex is beyond the scope of this chapter. Nonetheless the example below uses regex to select any column with an underscore in the column name followed by any character. The result is the same as the above for the contains() command. However, the matches() command is more flexible than the contains() command and can take into account substantially more complicated situations. data_matched&lt;- data_exp %&gt;% select(matches(&quot;(_.)&quot;)) You can see the columns selected using regex: glimpse(data_matched) ## Rows: 6 ## Columns: 4 ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 You can learn about regex at RegexOne and test your regex specification at Regex101. Ideally though, as we discuss in the next chapter, you can use naming conventions that are sufficiently thoughtful that you don’t need regex, or only rarely. The reason for this is that regex can be challenging to use. As Twitter user @ThatJenPerson noted “Regex is like tequila: use it to try to solve a problem and now you have two problems.” Nonetheless, at one or two points in the future we will use regex to solve a problem (but not tequila). 2.5.1.2 select() using column type If many cases we will want to select or perform an action on a column based on whether the column is a numeric, character, or factor column (indicated in glimpse output as dbl, chr, and fct, respectively). We will learn more about factors later in this chapter. Each of these column types can be selected by using is.numeric, is.character, or is.factor, respectively, in combination with the where() command. We can select numeric columns using where() and is.numeric: data_numeric_columns &lt;- data_exp %&gt;% select(where(is.numeric)) You can see the new data contains only the numeric columns: glimpse(data_numeric_columns) ## Rows: 6 ## Columns: 5 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 We can select numeric columns using where() and is.character: data_character_columns &lt;- data_exp %&gt;% select(where(is.character)) You can see the new data contains only the character columns: glimpse(data_character_columns) ## Rows: 6 ## Columns: 1 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;… If a future chapter you will see how we can select factors using where(is.factor). 2.5.2 summarise() The summarise() command can summarise multiple columns when combined with starts_with(), ends_with(), contains(), matches(), and where(). However, to use these powerful tools for indicating columns with the summarise command we need the help of the across() command (i.e., across multiple columns). If we want to obtain the mean of all the columns that start with “t1” we use the commands below. The across command requires that we indicate the columns we want via the .cols argument and the command/function we want to run on those columns via the .fns argument. In the example below, we also add na.rm = TRUE at the end; this is something we send to the mean command to let it know how we want to handle missing data. We add as.data.frame() to get a larger number of decimals. data_exp %&gt;% summarise(across(.cols = starts_with(&quot;t1&quot;), .fns = mean, na.rm = TRUE)) %&gt;% as.data.frame() ## t1_vomit t1_aggression ## 1 1.833 5.5 If you want to get more sophisticated, you can also add this .names argument below which tells R to call label each output mean by the column name followed by \"_mean\". data_exp %&gt;% summarise(across(.cols = starts_with(&quot;t1&quot;), .fns = mean, na.rm = TRUE, .names = &quot;{col}_mean&quot;)) %&gt;% as.data.frame() ## t1_vomit_mean t1_aggression_mean ## 1 1.833 5.5 Often you want to calculate more than one statistic for each column. For example, you might want the mean, standard deviation, min, and max. These statistics can be calculated via the mean, sd, min, and max commands, respectively. However, you need to create a list with the statistics you desire. Below we create a list of the descriptive statistics we desire called desired_statistics, but you can use any name you want. This list only needs to be specified once, but we will repeat it in the examples below for clarity. desired_descriptives &lt;- list( mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE) ) Once you have created the list of descriptive statistics you want you can run the command below to obtain those statistics. However, as you will see the output is too wide to be helpful. data_exp %&gt;% summarise(across(.cols = starts_with(&quot;t1&quot;), .fns = desired_descriptives)) %&gt;% as.data.frame() ## t1_vomit_mean t1_vomit_sd t1_aggression_mean ## 1 1.833 1.169 5.5 ## t1_aggression_sd ## 1 1.871 Consequently, we add the t() command (i.e., transpose command) to the end of the summarise request to get a more readable list of statistics: desired_descriptives &lt;- list( mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE) ) data_exp %&gt;% summarise(across(.cols = starts_with(&quot;t1&quot;), .fns = desired_descriptives)) %&gt;% as.data.frame() %&gt;% t() ## [,1] ## t1_vomit_mean 1.833 ## t1_vomit_sd 1.169 ## t1_aggression_mean 5.500 ## t1_aggression_sd 1.871 Note that in the across command above we could also have used: ends_with(), contains(), matches(), or where(). 2.5.3 mutate() The mutate() command can also be applied to multiple columns using the across() command. However, sometimes we need to embed our calculation in a custom function. Below is a custom function called make_centered. This custom function takes the values in a column and subtracts the column mean from each value in the column. This is the same task we did previous using the mutate() command in the basic tidyverse section. make_centered &lt;- function(values) { values_out &lt;- values - mean(values, na.rm = TRUE) return(values_out) } The glimpse() command shows us all the column names. Also notice the values in the agresssion columns are integers. glimpse(data_exp) ## Rows: 6 ## Columns: 6 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,… ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; 5, 6, 4, 7, 3, 8 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; 6, 7, 6, 7, 5, 8 We combine the mutate() command, with the across() command, and our custom make_centered() command below. The command “centers” or subtracts the mean from any column that ends with “aggression”. data_exp &lt;- data_exp %&gt;% mutate(across(.cols = ends_with(&quot;aggression&quot;), .fns = make_centered)) You can see via the glimpse() output that the contents of all the columns that end with “aggression” have changed. Every value in one these columns has had the column mean subtracted from it. glimpse(data_exp) ## Rows: 6 ## Columns: 6 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,… ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; -0.5, 0.5, -1.5, 1.5, -2.5, 2.5 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; -0.5, 0.5, -0.5, 0.5, -1.5, 1.5 Note that in the across() command above, we could also have used: starts_with(), contains(), matches(), or where(). 2.5.3.1 mutate() within rows Researchers often want to average within rows and across columns to create a new column. That is, for each participant (i.e., rat in the current data) we might want to calculate a vomit score that is the average of the two time points (that we will call vomit_avg). To average within rows (and across columns) we use the rowwise() command to inform R of our intent. However, after we do the necessary calculations we have to shut off the rowwise() calculation state by using the ungroup() command. As well, when we are averaging within rows we have to use c_across() instead of across(). The commands below create a new column called vomit_avg which is the average of the vomit ratings across both times. As before, we also include na.rm = TRUE so the computer drops missing values (if present) when calculating the mean. data_exp &lt;- data_exp %&gt;% rowwise() %&gt;% mutate(vomit_avg = mean( c_across(cols = ends_with(&quot;vomit&quot;)), na.rm = TRUE)) %&gt;% ungroup() You can see the new column we created with the glimpse() command: glimpse(data_exp) ## Rows: 6 ## Columns: 7 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,… ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; -0.5, 0.5, -1.5, 1.5, -2.5, 2.5 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; -0.5, 0.5, -0.5, 0.5, -1.5, 1.5 ## $ vomit_avg &lt;dbl&gt; 2.5, 1.5, 0.5, 2.5, 1.5, 1.5 The print() command could make it easier to see that the new column is the average of the other two, but if we use the print() command below it wouldn’t work. Why? There are too many columns in the data set, so only the first few columns are shown. print(data_exp) To see that the new column, vomit_avg, is the average of the other vomit columns we use the select command before print(). This prints only the relvant columns. When this is done, it’s easy to see how the values in the vomit_avg column are the mean of the other two columns. data_exp %&gt;% select(contains(&quot;vomit&quot;)) %&gt;% print() ## # A tibble: 6 x 3 ## t1_vomit t2_vomit vomit_avg ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 2 2.5 ## 2 2 1 1.5 ## 3 0 1 0.5 ## 4 3 2 2.5 ## 5 2 1 1.5 ## 6 1 2 1.5 2.5.3.2 mutate() within rows using column names Sometimes it can be difficult to use one of the advanced select commands to obtain the columns you need to average across. The advanced commands like ends_with() and starts_with() can sometimes include columns you don’t want. The command below is equivalent the one above, however, we explicitly name the variables we want to average across. data_exp &lt;- data_exp %&gt;% rowwise() %&gt;% mutate(vomit_avg = mean( c_across(cols = c(t1_vomit, t2_vomit)), na.rm = TRUE)) %&gt;% ungroup() You can use print() to confirm we get the same result: data_exp %&gt;% select(contains(&quot;vomit&quot;)) %&gt;% print() ## # A tibble: 6 x 3 ## t1_vomit t2_vomit vomit_avg ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 2 2.5 ## 2 2 1 1.5 ## 3 0 1 0.5 ## 4 3 2 2.5 ## 5 2 1 1.5 ## 6 1 2 1.5 2.5.3.3 mutate() for factors It is critical that you indicate to R that categorical variables are in fact categorical variables. In R, categorical variables are referred to as factors. For humans, a factor like sex has three possible levels: female, male, intersex. An inspection of the glimpse() command output reveals that the sex column has the type character - as indicated by “chr”. Also notice, as you inspect this output, that we use words (e.g., female) to indicate the sex in the column rather than a number to represent a female participant (e.g., 2). This is the preferred, but less common, approach to entering data. glimpse(data_exp) ## Rows: 6 ## Columns: 7 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,… ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; -0.5, 0.5, -1.5, 1.5, -2.5, 2.5 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; -0.5, 0.5, -0.5, 0.5, -1.5, 1.5 ## $ vomit_avg &lt;dbl&gt; 2.5, 1.5, 0.5, 2.5, 1.5, 1.5 We need to convert the sex column to a factor in order for R to handle it appropriately in analyses. Failure to indicate the column is a factor could result in R conducting all the analyses and presenting incorrect results. Consequently, it is critical that we covert the column to a factor. Fortunately, that is easily done using the as_factor() command (there is also an as.factor command if as_factor won’t work for some reason). We convert the sex column to a factor with this code: data_exp &lt;- data_exp %&gt;% mutate(sex = as_factor(sex)) You can confirm this worked with the glimpse() command: glimpse(data_exp) ## Rows: 6 ## Columns: 7 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6 ## $ sex &lt;fct&gt; male, female, male, female, male, f… ## $ t1_vomit &lt;dbl&gt; 3, 2, 0, 3, 2, 1 ## $ t1_aggression &lt;dbl&gt; -0.5, 0.5, -1.5, 1.5, -2.5, 2.5 ## $ t2_vomit &lt;dbl&gt; 2, 1, 1, 2, 1, 2 ## $ t2_aggression &lt;dbl&gt; -0.5, 0.5, -0.5, 0.5, -1.5, 1.5 ## $ vomit_avg &lt;dbl&gt; 2.5, 1.5, 0.5, 2.5, 1.5, 1.5 If you entered your data using words for each level of sex (e.g., male, female) you’re done at this point. However, if you used numbers to represent each level of sex in your data, there is one more step. Imagine your data was entered in a poorly advised manner, such that 1 was used to indicate male, 2 was used to indicate female, and 3 was used to indicate intersex. If this was the case, you need to indicate to R what each of those values represent. We do that with the code below. data_exp &lt;- data_exp %&gt;% mutate(sex = fct_recode(sex, male = &quot;1&quot;, female = &quot;2&quot;, intersex = &quot;3&quot;)) 2.6 Using help In order to become efficient at analyzing data using R, you will need to become adapt at reading and understanding the help files associated with each command. After you have activated a package using the library command (e.g., library(tidyverse)) you can access the help page for every command in that package. To access the help page simply type a question mark followed by the command you want to know how to use (no space between them). The code below brings up the help page for the select() command. Notice that we put the library() command first - just a reminder that this needs to be done prior to using help for that package. Try the commands below in the Console: library(tidyverse) ?select Examine the page that appears on the Help tab in the panel in the lower right of your screen. Read through the help file comparing what you read there to what we have learned about the select command. Notice how the help file tells you about the argument that you sent into the select() command, and also what the select() command returns when it receives those commands. Pay particular attention to the examples near the bottom of the help page. At the very bottom of the help page you will see [Package dplyr version 1.0.0 Index]. This tells you the select() command is from the dplyr package (part of the tidyverse). Notice that the word “Index” is underlined. Click on the word Index. You will be presented with list of other commands in the dplyr package. As you become more experienced with R help pages, this is how you will learn to use new commands. Examine the help pages for the commands below by typing a question mark into the Console followed by the command name. Note that for filter and starts_with you will be presented with a menu instead of help page. This typically occurs because the command is in more than one package. If this does occur, read through the options you are presented with to try and figure out which one you wanted. Typically, you want the first option. If you’re not sure, try one. IF it’s not what you want, use the back arrow in the Help panel to go back and pick another one. mutate filter starts_with 2.7 Base R vs tidyverse All of the commands used to this point in the chapter have been the tidyverse approach to using R. That is the approach we will normally use. However, it’s important to note that there is another way of using R, called base R. Sometimes students have problems with their code when they mix and match these approaches using a bit of both. We will be using the tidyverse approach to using R but on the internet you will often see sample code that uses the older base R approach. A bit of background knowledge is helpful for understanding why we do things one way (e.g., read_csv with the tidyverse) instead of another (e.g., read.csv with base R). 2.7.1 Tibbles vs. data frames When you load data into R, it is typically represented in one of two formats inside the computer - depending on the command you used. The original format for representing a data set in R is the data frame. You will see this term used frequently when you read about R. When you load data using read.csv(), your data is loaded into a data frame in the computer. That is, your data is represented in the memory of the computer in a particular format and structure called a data frame. This contrasts with the newer tidyverse approach to representing data in the computer called a tibble - which is just a newer more advanced version of the data frame. 2.7.2 read.csv() and data frames When you read data into R using the command read.csv() (with a period) you load the data into a data frame (base R). my_dataframe &lt;- read.csv(file = &quot;data_okcupid.csv&quot;) Notice that when you print a data frame it does not show you the number of rows or columns above the data like our example did with the okcupid_profiles data. Likewise, it does not show you the type of data in each column (e.g., dbl, fct, chr). It also presents all of your data rather than just the first few rows (as the tibble does). As a result, in the output below, we show only the first 10 rows of the output - because all the rows are printed in your Console with a data frame (too much to show here). print(my_dataframe) ## age diet height pets ## 1 22 strictly anything 75 likes dogs and likes cats ## 2 35 mostly other 70 likes dogs and likes cats ## 3 38 anything 68 has cats ## 4 23 vegetarian 71 likes cats ## 5 29 &lt;NA&gt; 66 likes dogs and likes cats ## 6 29 mostly anything 67 likes cats ## 7 32 strictly anything 65 likes dogs and likes cats ## 8 31 mostly anything 65 likes dogs and likes cats ## 9 24 strictly anything 67 likes dogs and likes cats ## 10 37 mostly anything 65 likes dogs and likes cats ## sex status ## 1 m single ## 2 m single ## 3 m available ## 4 m single ## 5 m single ## 6 m single ## 7 f single ## 8 f single ## 9 f single ## 10 m single 2.7.3 read_csv() and tibbles When you read data into R using the command read_csv() (with an underscore) you load the data into a tibble (tidyverse). my_tibble &lt;- read_csv(file = &quot;data_okcupid.csv&quot;) ## ## ── Column specification ──────────────────────────────────── ## cols( ## age = col_double(), ## diet = col_character(), ## height = col_double(), ## pets = col_character(), ## sex = col_character(), ## status = col_character() ## ) The tibble is modern version of the data frame. Notice that when you print a tibble it DOES show you the number of rows and columns. As well, it shows you the type of data in each column. Importantly, the tibble only provides the first few rows of output so it doesn’t fill your screen. print(my_tibble) ## # A tibble: 59,946 x 6 ## age diet height pets sex status ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 22 strictly an… 75 likes dogs and l… m single ## 2 35 mostly other 70 likes dogs and l… m single ## 3 38 anything 68 has cats m availa… ## 4 23 vegetarian 71 likes cats m single ## 5 29 &lt;NA&gt; 66 likes dogs and l… m single ## 6 29 mostly anyt… 67 likes cats m single ## 7 32 strictly an… 65 likes dogs and l… f single ## 8 31 mostly anyt… 65 likes dogs and l… f single ## 9 24 strictly an… 67 likes dogs and l… f single ## 10 37 mostly anyt… 65 likes dogs and l… m single ## # … with 59,936 more rows In short, you should always use tibbles (i.e., use read_csv() not read.csv()). The differences between data frames and tibbles run deeper than the superficial output provided here. On some rare occasions an old package or command may not work with a tibble so you need to make it a data frame. You can do so with the commands below. We will flag these rare occurances to you when they occur. # Create a data frame from a tibble new_dataframe &lt;- as.data.frame(my_tibble) "],["graphing.html", "Chapter 3 Graphing 3.1 Required 3.2 Data 3.3 Graph basics 3.4 Graphing efficiently 3.5 Aesthetics 3.6 APA style 3.7 Axes 3.8 Axis values 3.9 Custom colours 3.10 Emoji 3.11 Accessible Colors 3.12 Saving", " Chapter 3 Graphing 3.1 Required The data files below are used in this chapter. The files are available at: https://github.com/dstanley4/psyc3250bookdown Required Data data_movies.csv The following packages CRAN must be installed: Required CRAN Packages tidyverse RColorBrewer remotes The following GitHub packages must be installed: Required GitHub Packages dill/emoGG After the remotes package is installed, it can be used to install a package from GitHub: remotes::install_github(&quot;dill/emoGG&quot;) 3.2 Data To learn about making graphs using the tidyverse we use movie ratings and box office data obtained at the time of writing. Movie ratings were obtained from the IMDB and RottenTomatoes. Box office data (in millions of dollars) was obtained from Box Office Mojo. If you enjoy learning about movies these are all excellent sites. We begin by loading data_movies.csv using read_csv(), not read.csv(): movie_data &lt;- read_csv(&quot;data_movies.csv&quot;) Next we inspect movie_data using the print() command. We see that each row of the data set corresponds to a superhero movie. print(movie_data) ## # A tibble: 8 x 7 ## title short_title year imdb tomatoes_aud boxoffice ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Iron… Iron 2008 7.9 96 585 ## 2 Thor… Thor 2017 7.9 93 854 ## 3 Aven… AV3 2018 8.5 91 2048 ## 4 Aven… AV4 2019 8.7 91 2744 ## 5 Man … Sup 2013 7.1 75 668 ## 6 Batm… BvS 2015 6.5 63 873 ## 7 Just… JL 2017 6.5 72 657 ## 8 Wond… WW 2017 7.5 88 821 ## # … with 1 more variable: studio &lt;chr&gt; Next we use glimpse() to see the columns. glimpse(movie_data) ## Rows: 8 ## Columns: 7 ## $ title &lt;chr&gt; &quot;Iron Man&quot;, &quot;Thor Ragnarok&quot;, &quot;Avenge… ## $ short_title &lt;chr&gt; &quot;Iron&quot;, &quot;Thor&quot;, &quot;AV3&quot;, &quot;AV4&quot;, &quot;Sup&quot;,… ## $ year &lt;dbl&gt; 2008, 2017, 2018, 2019, 2013, 2015, … ## $ imdb &lt;dbl&gt; 7.9, 7.9, 8.5, 8.7, 7.1, 6.5, 6.5, 7… ## $ tomatoes_aud &lt;dbl&gt; 96, 93, 91, 91, 75, 63, 72, 88 ## $ boxoffice &lt;dbl&gt; 585, 854, 2048, 2744, 668, 873, 657,… ## $ studio &lt;chr&gt; &quot;Marvel&quot;, &quot;Marvel&quot;, &quot;Marvel&quot;, &quot;Marve… The title and short_title columns provide the full title and short title for each movie. Additionally, the IMDB rating, the Rotten Tomatoes Audience rating, and the Box Office Mojo revenue numbers are provided in the imdb, tomatoes_aud, and boxoffice columns, respectively. Finally, the last column, studio, indicates the studio that made the movie (Marvel or DC). It is extremely important for graphing and analyses that you tell R which columns are composed of categorical variables. We do that using the as_factor command. The as_factor command turns a column into a categorical column. We use the mutate command to replace the original column with the column that has been defined as a categorical variables using as_factor. movie_data &lt;- movie_data %&gt;% mutate(across(.cols = where(is.character), .fns = as_factor)) We can confirm the column type has changed by using the glimpse() command again and examing the column types: glimpse(movie_data) ## Rows: 8 ## Columns: 7 ## $ title &lt;fct&gt; Iron Man, Thor Ragnarok, Avengers In… ## $ short_title &lt;fct&gt; Iron, Thor, AV3, AV4, Sup, BvS, JL, … ## $ year &lt;dbl&gt; 2008, 2017, 2018, 2019, 2013, 2015, … ## $ imdb &lt;dbl&gt; 7.9, 7.9, 8.5, 8.7, 7.1, 6.5, 6.5, 7… ## $ tomatoes_aud &lt;dbl&gt; 96, 93, 91, 91, 75, 63, 72, 88 ## $ boxoffice &lt;dbl&gt; 585, 854, 2048, 2744, 668, 873, 657,… ## $ studio &lt;fct&gt; Marvel, Marvel, Marvel, Marvel, DC, … 3.3 Graph basics In this section we teach you how to make a graph from first principles to form a foundation for understanding how the tidyverse graphing command ggplot() works. Note, however, that the approach used for creating a graph in this section is for teaching purposes only. Later we will make graphs in a typical, and more efficient, manner. We start a graph using the ggplot() command. The ggplot() command creates an empty template for the graph. After creating the template we have to add content (like bars) to the graph using the geom_col() command. We can also add text using the geom_text() command. Commands that plot information on the graph, such as geom_col(), need to know what data set to use to create the graph. We specify the data set to use via the data argument. For example, we use “data = movie_data” to tell a command which data set to use. Additionally, graphing commands, such as geom_col(), must know the columns/variables to use within that data set when plotting the graph. Specifically, commands need to know which variable/column will vary over the x- and y-axes. We can indicate these columns via the mapping argument. For example, we use “mapping = aes(x = short_title, y = boxoffice)” to tell ggplot() that we should use the column short_title along the x-axis and the column boxoffice when determining heights on the y-axis. This information is nested within the aes() command which is short for aesthetic. You are telling ggplot() about the aesthetics for the graph (i.e., which columns to use for the x- and y-axes) using the aes() command. There are a larger number of aesthetics that you can specify within the aes() command (e.g., color, fill, linetype, etc.). In the examples that follow we tell each command (geom_col, geom_text) which data set and columns to use via the data and mapping arguments. Use geom_col() to put each boxoffice column value into a bar. my_graph &lt;- ggplot() + geom_col(data = movie_data, mapping = aes(x = short_title, y = boxoffice)) print(my_graph) Next, we want to put the boxoffice revenue above each bar so it easier to interpret. In R terms, we are putting a label above each bar. We want the contents for the labels to come from the boxoffice column. Therefore, we add the geom_text() command below: my_graph &lt;- ggplot() + geom_col(data = movie_data, mapping = aes(x = short_title, y = boxoffice)) + geom_text(data = movie_data, mapping = aes(x = short_title, y = boxoffice, label = boxoffice)) print(my_graph) Unfortunately, when we position the text at the exact height of each column it overlaps with the column making it difficult to read. We fix this on the next page using nudge_y. We can nudge each label higher on the y-axis using the nudge_y command. In the above code, we nudge it up 150 units. Since nudge_y uses the values on the y-axis we are nudging the labels up by 150 million on the y-axis. my_graph &lt;- ggplot() + geom_col(data = movie_data, mapping = aes(x = short_title, y = boxoffice)) + geom_text(data = movie_data, mapping = aes(x = short_title, y = boxoffice, label = boxoffice), nudge_y = 150) print(my_graph) 3.4 Graphing efficiently You may have noticed that creating the graphs the way we did above required repeating the data and mapping assignments within each command (e.g., geom_text, geom_col). Fortunately, we can use a shortcut and specify the data and mapping only once in the ggplot() command. Once we do that, the contents of the mapping argument are invisibly copied into each subsequent command (e.g., geom_col, geom_text). In this way, we only have to specify the data and the mapping once. Examine the code below and compare it to the code above. Notice how in the geom_col() command we don’t have anything specified – the data and mapping from the ggplot command are used. Likewise, notice how in the geom_text() command we only specify the arguments we need that are different from those in the ggplot command. In this case, that means simply adding the nudge_y = 150 to the geom_text command. my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = short_title, y = boxoffice, label = boxoffice)) + geom_col() + geom_text(nudge_y = 150) print(my_graph) 3.5 Aesthetics Exactly how does that aesthetic, aes(), command work? What happens when we put the data and mapping in the ggplot() command instead of the specific commands such as geom_col()? When we put data and the mapping arguments in the ggplot() command we set those attributes for the entire graph. To understand this, you need to know that ggplot uses an internal data set that we will call the “black box” data set (i.e., inside the black box of ggplot). To create a graph ggplot maps/copies columns from your data set (e.g., movie_data) to an internal data set. This internal data set is then used to create the graph. Figure 3.1 below illustrates what is happening “inside the black box” when you create the graph using the code above. FIGURE 3.1: Internal data structure for ggplot 3.5.1 Fill color You might want to influence the color of the bars in the graph such that the bars for Marvel and DC movies have different colors. That’s easy to do with the aes() command. We simply tell aes() that the fill color of any object in the graph should be determined by the studio column. Simply adding “fill = studio” to the aes() command changes the colors of the bars – and any other object on the graph for which fill would be relevant. The internal workings are illustrated in Figure 3.2. my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = short_title, y = boxoffice, label = boxoffice, fill = studio )) + geom_col() + geom_text(nudge_y = 150) print(my_graph) FIGURE 3.2: Adding a fill column to the internal data 3.5.2 Overriding aes() Just because you specify something in the ggplot() command doesn’t mean that you are “stuck with it” for all your subsequent commands. Recall how at the start of this exercise we specified the data and the mapping for each geom_col() and geom_text() individually. We can still do that. Now we want to add the Rotten Tomatoes Audience score for each movie above the box office revenue. But if we use geom_text(), like we did before, it will plot the same boxoffice information because of “label = boxoffice” in the aes() specification within ggplot(). We want the new geom_text() command to plot different text; that is, we want it to use “label = tomatoes_aud”. Fortunately, if we simply put “mapping = aes(label = tomatoes_aud)” within the new geom_text() command we get the desired information on the graph. The mapping/aes arguments within geom_text() override the mapping/aes arguments within ggplot(). Or more accurately, the new geom_text() command creates its own version of the internal data set in which the label column is filled with information from tomatoes_aud. my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = short_title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud)) print(my_graph) Notice that we have the same problem as before with the text being difficult to read because it overlaps with the bar. We add “nudge_y = 400” to move the text higher than the boxoffice text/label. Don’t forget the units used by nudge_y are the units on the y-axis. my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = short_title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) print(my_graph) 3.6 APA style Use theme_classic() to make the graph apear in APA style. We use theme_classic(12) to make the graph APA style with a 12-point font: my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = short_title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + theme_classic(12) print(my_graph) 3.7 Axes 3.7.1 Range We use the coord_cartesian() command to adjust range of axes. In the code below we use coord_cartesian() to make the y-axis range from 0 to 3500. my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = short_title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + theme_classic(12) print(my_graph) Note that if you had a continuous variable on the x-axis (we do not in this example), you could set the range of both the x- and y-axes like this: coord_cartesian(ylim = c(0, 3500), xlim = c(0, 3500)) 3.7.2 Ticks We use the scale_y_continuous() command to adjust the ticks on the y-axis. We set the ticks on the y-axis to range from 0 to 3500 in 500 tick increments using the scale_y_continuous command below via the breaks argument: my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = short_title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + theme_classic(12) print(my_graph) Note that if you had a continuous variable on the x-axis (we do not in this example), you could set the ticks of the x-axis like the code below using scale_x_continuous: scale_x_continuous(breaks = seq(0, 3500, by = 500)) 3.7.3 Labels Labels are an extremely important part of any graph. This fact is the focus of the xkcd cartoon below: We use the labs() command to set the labels for the x- and y-axes: my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = short_title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) print(my_graph) 3.8 Axis values 3.8.1 Text What if we want to use the full movie title rather than the short version on the x-axis of the graph? That is, you want to change the values along the x-axis. Two methods are presented below. 3.8.1.1 Method 1: Recoding axis values Our data file contains a column with the long/full version of the movie names. But many times you won’t have the additional/longer labels available in this manner. In this situation, you use the scale_x_discrete() command to change the values along the x-axis. The values along the x-axis come from the short_title column which is a factor. The levels of that factor correspond to the short titles for the movies (Iron, Thor, etc.). We need to relabel the levels of the short_title factor to get a graph with full titles. We relabel the levels of the short_title factor using the scale_x_discrete() command. The graph code with scale_x_discrete() command is below - notice the problem we have with the labels overlapping though. On the next page, we’ll use an easier approach though - since we have an extra column with the full titles. my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = short_title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + scale_x_discrete(labels=c(&quot;Iron&quot; = &quot;Iron Man&quot;, &quot;Thor&quot; = &quot;Thor Ragnarkok&quot;, &quot;AV3&quot; = &quot;Avengers Infinity War&quot;, &quot;AV4&quot; = &quot;Avengers Endgame&quot;, &quot;Sup&quot; = &quot;Man of Steel&quot;, &quot;BvS&quot; = &quot;Batman v Superman&quot;, &quot;JL&quot; = &quot;Justice League&quot;, &quot;WW&quot; = &quot;Wonder Woman&quot;)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) print(my_graph) 3.8.1.2 Method 2: Longer label columns With our movie data we don’t need to use scale_x_discrete() because we have a column in the data with the full titles. Consequently, to use full length titles we just have to change the mappingfor x from short_title to title. Notice that we still have the problem with overlapping labels on the x-axis! my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) print(my_graph) 3.8.2 Angle Use theme() to adjust the angle of x-axis labels. Notice, however, that the longer titles are vertically centered on each point on the x-axis. In the next section we fix this problem. Important: The theme command must come after the theme_classic command. Otherwise, theme_classic will undo the work done by the theme_command if it appears after the theme command. my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60)) print(my_graph) 3.8.3 Alignment Use theme() and the hjust argument to adjust the alignment of the x-axis labels. To make the titles look correct on the x-axis we need them at an angle, but we also need them right justified against the x-axis. We do that with the the hjust argument (1 means right justify). See the code below: my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) print(my_graph) 3.8.4 Order 3.8.4.1 Increasing order We can make the movie bars go left to right in lowest to highest box office receipt order by changing the factor order prior to creating the graph. We do so with the mutate() and fct_reorder() commands. The default order is ascending values even though we don’t specify it. movie_data &lt;- movie_data %&gt;% mutate(title = fct_reorder(title, boxoffice)) my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) print(my_graph) 3.8.4.2 Decreasing order We can make the movie bars go left to right in highest to lowest box office receipt order by changing the factor order prior to creating the graph. We use the same code as before but add the desc() command (i.e.,descending) around boxoffice in the fct_reorder() call: movie_data &lt;- movie_data %&gt;% mutate(title = fct_reorder(title, desc(boxoffice))) my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) print(my_graph) 3.8.4.3 Custom order We can make the movie bars go left to right in a custom order by changing the factor order prior to creating the graph. Because we want a custom order of the factor levels we use fct_relevel(), instead of the the fct_reorder() command from the previous two examples. Below I use this approach to manually order movies highest to lowest boxoffice within movie studio (Marvel or DC). movie_data &lt;- movie_data %&gt;% mutate(title = fct_relevel(title, &quot;Avengers Endgame&quot;, &quot;Avengers Infinity War&quot;, &quot;Thor Ragnarok&quot;, &quot;Iron Man&quot;, &quot;Batman v Superman&quot;, &quot;Wonder Woman&quot;, &quot;Man of Steel&quot;, &quot;Justice League&quot;)) my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) 3.8.5 Legend order After inspecting the graph on the previous page, you might think that Marvel should be above DC in the legend. You can do that by reordering the studio factor: movie_data &lt;- movie_data %&gt;% mutate(studio = fct_relevel(studio, &quot;Marvel&quot;, &quot;DC&quot;)) my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) 3.9 Custom colours 3.9.1 R palette You might look at the previous graph and think “Marvel should be red and DC should be blue since those are the colours of their respective logos”. You can do that with the code below. Note that you specify the colours in the order the names appear in the legend (top to bottom). R colour names/pictures can be found here: http://sape.inf.usi.ch/quick-reference/ggplot2/colour my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) + scale_fill_manual(values = c(&quot;red&quot;, &quot;blue&quot;)) 3.9.2 Hex colours If you are a really big geek (like me) you might look at the previous graph and think “Those aren’t the proper colours for the Marvel and DC - lame!” So… you do some internet research and determine that you can specify colours using hexidecimal numbers. More specifically, you find Marvel red is #ed1d24 and DC blue is #0476F2 using hex colour codes. You can use those precise colours via the scale_fill_manual() command below. my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 400) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) + scale_fill_manual(values = c(&quot;#ed1d24&quot;, &quot;#0476F2&quot;)) 3.10 Emoji Make the graph more fun with the emoGG package. You might like to make the graph more fun by putting tomatoes on the graph to indicate what the extra numbers mean. We can do that with the emoGG package. The installation instructions for this package are at the start of this chapter; note, that it is installed via GitHub rather than the CRAN. Course R Studio Cloud users - the installation has already been done. After installation you need to activate the emoGG package: library(emoGG) Visit this link to check out the codes for emoji: https://apps.timwhitlock.info/emoji/tables/unicode If you scroll down to section 5 Uncategorized on this page you will find the code for a tomato is 1f345. Note that the code below will only work with an internet connection. The command geom_emoji() needs internet access to retrieve the emoji graphic requested. my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 600, colour = &quot;red&quot;) + geom_emoji(mapping = aes(y = boxoffice + 400), emoji=&quot;1f345&quot;) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) + scale_fill_manual(values = c(&quot;#ed1d24&quot;, &quot;#0476F2&quot;)) 3.11 Accessible Colors The current version of the graph is much improved from where we started at the begining of the chapter. One notable improvement was the use of the “proper” colors for the Marvel and DC studios. Although using these colors was aethetically pleasing, a major consideration is ensuring your graphs are accessible to a wide audience. Color blindness is an issue that affects approximately five percent of the population. A nuanced discussion of the different types of color blindness is beyond the scope of this chapter. We can, however, take a momement to think about every graph as being composed of two parts that work together to create the colors overall image. We can think of there being a lightness (i.e., light vs. dark) component and a hue component (e.g., magenta, yellow, etc.). Together these two components work together to create colors that we see. This distinction between lightness and hue is relevant to all images not just graphs (see Margulis 2005). FIGURE 3.3: Hue removed from current graph Figure 3.3A presents our current graph whereas Figure 3.3B presents the same graph with the hue component removed. You can see that when the hue component is removed that the distinction between the Marvel and DC bars is also removed. The particular colors used to represent Marvel/DC differ in terms of hue but not lightness. Consequently, when we remove the hue component we are left with a graph, 3.3B, that does not differentiate between the two studios. In order for a color graph to be accessible to people with color blindness we need to pick colors that vary in terms of lightness as well as hue. We can do that with the help of the RColorBrewer package. 3.11.1 RColorBrewer 3.11.1.1 Picking a palette The RColorBrewer package can be used to generate color palettes for graphs that are accessible to people with color blindness. That is, it creates sets of colors, called palettes, for which the colors vary in terms of both lightness and hue. You can see the color-blind accessible palettes, along with their respective names, by using the command below. This code produces a wide range of color-blind accessible palettes with a large number of colors in each palette - as illustrated in Figure 3.4. library(RColorBrewer) display.brewer.all(n = NULL, colorblindFriendly = TRUE) FIGURE 3.4: Wide range color palette (color-blind accessible) In Figure 3.4, above, we showed palettes with a large number of colors. But if you have a smaller number of possible colors in your graph - you want a palette with fewer colors (to ensure maximum contrast between those colors). You can, for example, obtain palettes with only three colors using the code below. library(RColorBrewer) display.brewer.all(n = 3, colorblindFriendly = TRUE) The above code generates the three-color palettes presented in Figure 3.5. FIGURE 3.5: Narrow range color palette (color-blind accessible) 3.11.1.2 Using a palette We can use a color palette by specifying its name within scale_fill_brewer(). We want to use the “Paired” palette in Figure 3.5 so we use the code: scale_fill_brewer(palette = “Paired”), as illustrated below: my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 600, colour = &quot;red&quot;) + geom_emoji(mapping = aes(y = boxoffice + 400), emoji=&quot;1f345&quot;) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) + scale_fill_brewer(palette = &quot;Paired&quot;) 3.11.1.3 Palette subsets Our graph had only two colors but the “Paired” palette had three colors. When ggplot made the graph it automatically used the first two colors of the three color palette. What if you wanted the second two colors in the palette? We can do that but we have to revert to a manual color process like we used before via the scale_fill_manual(). But we want to do so using the colors from the “Paired” palette. We can obtain the color codes for the “Paired” palette with the code below: brewer.pal(n = 3, name = &quot;Paired&quot;) ## [1] &quot;#A6CEE3&quot; &quot;#1F78B4&quot; &quot;#B2DF8A&quot; The numbers in the output correspond to values representing the three colors of the “Paired” palette, see Figure 3.6. If we want the last two colors in the palette for our graph that means we want the colors: #1F78B4 and #B2DF8A. FIGURE 3.6: Paired palette colors with hex numbers We can put the two colors we want (#1F78B4 and #B2DF8A) on the graph by using the scale_fill_manual() command - instead of the scale_fill_brewer() command. We can see this in the code below: my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 600, colour = &quot;red&quot;) + geom_emoji(mapping = aes(y = boxoffice + 400), emoji=&quot;1f345&quot;) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) + scale_fill_manual(values = c(&quot;#1F78B4&quot;, &quot;#B2DF8A&quot;)) Now that we have used a color-blind accessible palette in the graph we can look at the graph without the hue component. In Figure 3.7B, below, notice that the bars representing the two studios are easily distinguishable based on lightness alone. That is, the lightness graph in Figure 3.7B demonstrates the new color-blind accessible colors vary in term of both hue and lightness - not just hue. Therefore, when hue is removed the two colors are distinguishable. This makes the graph accessible to color-blind individuals. FIGURE 3.7: Color information (i.e., hue) removed from new color-blind accessible graph 3.11.2 Avoid color When you only have two colors on a graph another option for creating an accessible graph is to remove the colors entirely and make a black and white graph. In the code below we use scale_fill_manual() with the values “#ffffff” (white) and \"“#000000” (black). The intent was to create bars that are white for Marvel and black for DC. Unfortunately, because the graph has a white background you can see this resulted in the Marvel bars disappearing. my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col() + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 600, colour = &quot;red&quot;) + geom_emoji(mapping = aes(y = boxoffice + 400), emoji=&quot;1f345&quot;) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) + scale_fill_manual(values = c(&quot;#ffffff&quot;, &quot;#000000&quot;)) How do we get around the Marvel bars disappearing when we use white? Color vs. fill. The ggplot packages makes a distinction between fill and color. The term fill is used to refer to the inside color of bars. In contrast, color is used to the refer to the lines that outline the shape of each bar. In the previous code we used fill to change the colors of the bars but we did not use the “color” argument in a command. In the code below, we modify the geom_col() command to use the “color” argument. Specifically, we change geom_col() to geom_col(color = “black”). This change adds a black outline around all the bars – including the ones with a white fill. You can see the result is a much improved graph. This black/white graph is accessible to everyone. my_graph &lt;- ggplot(data = movie_data, mapping = aes(x = title, y = boxoffice, label = boxoffice, fill = studio)) + geom_col(color = &quot;black&quot;) + geom_text(nudge_y = 150) + geom_text(mapping = aes(label = tomatoes_aud), nudge_y = 600, colour = &quot;red&quot;) + geom_emoji(mapping = aes(y = boxoffice + 400), emoji=&quot;1f345&quot;) + coord_cartesian(ylim = c(0, 3500)) + scale_y_continuous(breaks = seq(0, 3500, by = 500)) + labs(x = &quot;Movie&quot;, y = &quot;Box office (millions)&quot;, fill = &quot;Studio&quot;) + theme_classic(12) + theme(axis.text.x = element_text(angle = 60, hjust = 1)) + scale_fill_manual(values = c(&quot;#ffffff&quot;, &quot;#000000&quot;)) 3.12 Saving If you have a Mac it is easy to drag and drop a PDF file into MS Word - so making a PDF file is the best bet for saving your graph. You can do so with the code below which creates a 6 inch by 6 inch graph. 3.12.1 MAC If you are able to use PDFs in your workflow that’s often the best option for saving. PDFs are mathematical in nature and therefore can be printed at any size at high quality. With a MAC you can just drag and drop the PDF file into your MSWord document. ggsave(plot = my_graph, filename = &quot;emoji_graph.pdf&quot;, width = 6, height = 6) 3.12.2 PC or MAC If you have a PC it’s hard to put a PDF into MSWord. Therefore, save the graph as a .jpg file. You do so with the code below. This creates a picture type file at a resolution (dpi = dots per inch) that is sufficiently high for quality printing. With a PC you need to use the INSERT menu and insert the graph as a picture in MSWord. With a MAC you can just drag and drop the .jpg file into your MSWord document. ggsave(plot = my_graph, filename = &quot;emoji_graph.jpg&quot;, width = 6, height = 6, dpi = &quot;print&quot;) References "],["data-entryanalysis.html", "Chapter 4 Data Entry/Analysis 4.1 Required Packages 4.2 Objective 4.3 Begin with the end in mind 4.4 Data collection considerations 4.5 Following the examples 4.6 Entering data into spreadsheets 4.7 Surveys: Single Occassion 4.8 Basic descriptive statistics", " Chapter 4 Data Entry/Analysis 4.1 Required Packages The data files below are used in this chapter. The files are available at: https://github.com/dstanley4/psyc3250bookdown Required Data data_item_scoring.csv The following CRAN packages must be installed: Required CRAN Packages apaTables Hmisc janitor psych skimr tidyverse Important Note: You should NOT use library(psych) at any point! There are major conflicts between the psych package and the tidyverse. We will access the psych package commands by preceding each command with psych:: instead of using library(psych). 4.2 Objective Due to a number of high profile failures to replicate study results (Nosek 2015) it’s become increasingly clear that there is a general crisis of confidence in many areas of science (Baker 2016). Statistical (and other) explanations have been offered (Simmons, Nelson, and Simonsohn 2011) for why it’s hard to replicate results across different sets of data. However, scientists are also finding it challenging to recreate the numbers in their own papers using their own data. Indeed, the editor of Molecular Brain asked authors to submit the data used to create the numbers in published papers and found that the wrong data was submitted for 40 out of 41 papers (Miyakawa 2020). Consequently, some researchers have suggested that it is critical to distinguish between replication and reproducibility (Patil P. 2019). Replication refers to trying to obtain the same result from a different data sets. Reproducibility refers to trying to obtain the same results from the same data set. Unfortunately, some authors use these two terms interchangeably and fail to make any distinction between them. I encourage you to make the distinction and the use the terms consist with use suggested by (Patil P. 2019). It may seem that reproducibility should be a given - but it’s not. Correspondingly, there is a trend for journals and authors to adopt Transparency and Openness Promotion (TOP) guidelines. These guidelines involve such things as making your materials, data, code, and analysis scripts available on public repositories so anyone can check your data. A new open science journal rating system has even emerged called the TOP Factor. The idea is not that open science articles are more trustworthy than other types of articles – the idea is that trust doesn’t play a role. Anyone can inspect the data using the scripts and data provided by authors. It’s really just the same as making your science available for auditing the way financial records can be audited. But just like in the world of business, some people don’t like the idea of making it possible for others to audit their work. The problems reported in Molecular Brain (doubtless common to many journals) are likely avoided with open science - because the data and scripts needed to reproduce the statistics in the articles are uploaded prior to publication. The TOP open science guidelines have made an impact and some newer journals, such as Meta Psychology, have fully embraced open science. Figure 4.1 shows the header from an article in Meta Psychology that clearly delineates the open science attributes of the article that used computer simulations (instead of participant data). Take note that the header even indicates who verified that the analyses in the article were reproducible. FIGURE 4.1: Open science in an article header In Canada, the majority of university research is funded by the Federal Government’s Tri-Agency (i.e., NSERC, SSHRC, CIHR). The agency has a new draft Data Management Policy in which they state that “The agencies believe that research data collected with the use of public funds belong, to the fullest extent possible, in the public domain and available for reuse by others.” The perspective of the funding agency on data ownership differs substantially from that of some researchers who incorrectly believe “they own their data”. In Canada at least, the government makes it clear that when tax payers fund research (through the Tri-Agency) the research data is public property. Additionally the Tri-Agency Data Management policy clearly indicates the responsibilities of funded researchers: \"Responsibilities of researchers include: incorporating data management best practices into their research; developing data management plans to guide the responsible collection, formatting, preservation and sharing of their data throughout the entire life cycle of a research project and beyond; following the requirements of applicable institutional and/or funding agency policies and professional or disciplinary standards; acknowledging and citing data sets that contribute to their research; and staying abreast of standards and expectations of their disciplinary community.\" As a result of this perspective on data, it’s important that you think about structuring your data for reuse by yourself and others before you collect it. Toward this end, properly documenting your data file and analysis scripts is critical. 4.3 Begin with the end in mind In this chapter we will walk you though the steps from data collection, data entry, loading raw data, and the creation of data you will analyze (analytic data) via pre-processing scripts. These steps are outlined in Figure 4.2. This figure makes a clear distinction between raw data and analytic data. Raw data refers to the data as you entered it into a spreadsheet or received it from survey software. Analytic data is the data that has been structured and processed so that it is ready for analysis. This pre-processing could include such things as identifying categorical variables to the computer, averaging multiple items into a scale score, and other tasks. It’s critical that you don’t think of the analysis of your data as being completely removed from the data collection and data entry choices you make. Poor choices at the data collection and data entry stage can make your life substantially more complicated when it comes time to write the pre-processing script that will convert your raw data to analytic data. The mantra of this chapter is begin with the end in mind. FIGURE 4.2: Data science pipeline by Roger Peng It’s difficult to being with the end in mind when you haven’t read later chapters. So, here we will be provide you with some general thoughts around different approaches to structuring data files and the naming conventions you can use when creating those data files. Indeed, in this chapter we strongly advocate that you use a naming convention for file, variable, and column names. This convention will save you hours of hassles and permit easy application of certain tidyverse commands. However, we must stress that although the naming convention we advocate is based on the tidyverse style guide, it is not “right” or “correct” - there are other naming conventions you can use. Any naming convention is better than no naming convention. The naming convention we advocate here will solve many problems. We encourage to use this system for for weeks or months over many projects - until you see the benefits of this system, and correspondingly its shortcomings. After you are well versed in the strengths/weaknesses of the naming conventions used here you may choose to create your own naming convention system. 4.3.1 Structuring data: Obtaining tidy data When conducting analyses in R it is typically necessary to have data in a format called tidy data (Wickham 2014). Tidy data, as defined by Hadley, involves (among other requirements) that: Each variable forms a column. Each observation forms a row. The tidy data format can be initially challenging for some researchers to understand because it is based on thinking about, and structuring data, in terms of observations/measurements instead of participants. In this section we will describe common approaches to entering animal and human participant data and how they can be done keeping the tidy data requirement in mind. It’s not essential that data be entered in a tidy data format but it is essential that you enter data in a manner that makes it easy to later convert data to a tidy data format. When dealing with animal or human participant data it’s common to enter data into a spreadsheet. Each row of the spreadsheet is typically used to represent a single participant and each column of the spreadsheet is used to represent a variable. Between participant data. Consider Table 4.1 which illustrates between participant data for six human participants running 5 kilometers. The first column is id, which indicates there are six unique participants and provides and identification number for each of them. The second column is sex, which is a variable, and there is one observation per for row, so sex also conforms to the tidy data specification. Finally, there is a last column five_km_time which is a variable with one observation per row – also conforming to tidy data specification. Thus, single occasion between subject data like this conforms to the tidy data specification. There is usually nothing you need to do to convert between participant data (or cross-sectional data) to be in a tidy data format. TABLE 4.1: Between participant data entered one row per participant id sex elapsed_time 1 male 40 2 female 35 3 male 38 4 female 33 5 male 42 6 female 36 Within participant data. Consider Table 4.2 which illustrates within participant data for six human participants running 5 kilometers - but on three different occasions. The first column is id, which indicates there are six unique participants and provides and identification number for each of them. The second column is sex, which is a variable, and there is one observation per for row, so sex also conforms to the tidy data specification. Next, there are three different columns (march, may, july) each of which contains elapsed time (in minutes) for the runner in a different month. Elapsed run times are spread out over three columns so elapse_time is not in a tidy data format. Moreover, it’s not clear from the data file that march, may, and july are levels of a variable called occasion. Nor is it clear that elapsed_times are recorded in each of those columns (i.e., the dependent variable is unknown/not labeled). Although this format is fine as a data entry format it clearly has problems associated with it when it comes time to analyze your data. TABLE 4.2: Within participant data entered one row per participant id sex march may july 1 male 40 37 35 2 female 35 32 30 3 male 38 35 33 4 female 33 30 28 5 male 42 39 37 6 female 36 33 31 TABLE 4.3: A tidy data version of the within participant data id sex occasion elapsed_time 1 male march 40 1 male may 37 1 male july 35 2 female march 35 2 female may 32 2 female july 30 3 male march 38 3 male may 35 3 male july 33 4 female march 33 4 female may 30 4 female july 28 5 male march 42 5 male may 39 5 male july 37 6 female march 36 6 female may 33 6 female july 31 Thus, a major problem with entering repeated measures data in the one row per person format is that there are hidden variables in the data and you need insider knowledge to know what the columns represent. That said, this is not necessarily a terrible way to enter your data as long as you have all of this missing information documented in a data code book. Disadvantages one row per participant Advantages one row per participant 1) Predictor variable (occasion) is hidden and spread over multiple columns 1) Easy to enter this way 2) Unclear that each month is a level of the predictor variable occasion 3) Dependent variable (elapsed_time) is not indicated 4) Unclear that elapsed_time is the measurement in each month column Fortunately, the problems with Table 4.2 can be largely resolved by converting the data to the a tidy data format. This can be done with the pivot_long() command that we will learn about later in this chapter. Thus, we can enter the data in the format of Table 4.2 and later convert it to a tidy data format. After this conversion the data will be appear as in Table 4.3. For elapsed_time variable this data is now in the tidy data format. Each row corresponds to a single elapsed_time observed. Each column corresponds to a single variable. Somewhat problematically, however, sex is repeated three times for each person (i.e., over the three rows) - and this can be confusing. However, if the focus in on analyzing elapsed time this tidy data format makes sense. Importantly, there is an id column for each participant so R knows that this information is repeated for each participant and is not confused by repeating the sex designation over three rows. Indirectly, this illustrates the importance of having an id column to indicate each unique participant. Why did we walk you through this technical treatment of structuring data at this point in time - so that you pay attention to the advice that follows. You can see at this point that you may well need to restructure your data for certain analyses. The ability to do so quickly and easily depends upon following the advice in this chapter around naming conventions for variables and other aspects of your analyses. You can imagine the challenges for converting the data in Figure 4.2 to the data in Figure 4.3 by hand. You want to be able to automate that process and others - which is made substantially easier if you follow the forthcoming advice about naming conventions in the tidyverse. 4.4 Data collection considerations Data can be collected in a wide variety of ways. Regardless of the method of data collection researchers typically come to data in one of two ways: 1) a research assistant enters the data into a spreadsheet type interface, or 2) the data is obtained as the output from computer software (e.g., Qualtrics, SurveyMonkey, Noldus, etc.). Regardless of the approach, it is critical to name your variables appropriately. For those using software, such as Qualtrics, this means setting up the software to use appropriate variable names PRIOR to data collection - so the exported file has desirable column names. For spreadsheet users, this means setting up the spreadsheet in which the data will be recorded with column names that are amenable to the future analyses you want to conduct. Although failure to take this thoughtful approach at the data collection stage can be overcome - it is only overcome with substantial manual effort. Therefore, as noted previously, we strongly encourage you to follow the naming conventions we espouse here when you set up your data recording regime. Additionally, we encourage you to give careful thought in advance to the codes you will use to record missing data. 4.4.1 Naming conventions To make your life easier down the road, it is critical you set up your spreadsheet or online survey such that it uses a naming convention prior to data collection. The naming conventions suggested here are adapted from the tidyverse style guide. Lowercase letters only If two word column names are necessary, only use the underscore (\"_\") character to separate words in the name. Avoid short decontextualized variable names like q1, q2, q3, etc. Do use moderate length column names. Aim to achieve a unique prefix for related columns so that those columns can be selected using the starts_with() command discussed in the previous chapter. Be sure to avoid short two or three letter prefixes for item names. Instead, use unique moderate length item prefixes so that it will easy to select those columns using start_with() such that you don’t accidentally get additionally columns you don’t want - that have a similar prefix. See the Likert-type item section below for additional details. If you have a column name that represents the levels of two repeated measures variables only use the underscore character to separate the levels of the different variables. See within-participant ANOVA section below for details. 4.4.2 Likert-type items A Likert-type item is typically composed of a statement with which participants are asked to agree or disagree. For example, participants could be asked to indicate the extent to which they agree with a number of statements such as “I like my job”. Then tey would be presented with response scale such as: 1 - Strongly Disagree, 2 - Moderately Disagree, 3 - Neutral, 4, Moderately Agree, 5 - Strongly Agree. A common question is, how should I enter the data? Enter numeric responses not labels. You should enter the numeric value for each item response (e.g., 5) into your data - not the label (e.g., Strongly Agree). The labels associated with each value can be applied later in a script, if needed. High numbers should be associated with more of the construct being measured. When designing your survey or data collection tools, it is important that you set the response options appropriately. If your scale measures job satisfaction, it is important that you collect data in a manner that ensures high numbers on the job satisfaction scale indicate high levels of job satisfaction. Therefore, assigning numbers makes sense using the 5-point scale: 1 - Strongly Disagree, 2 - Moderately Disagree, 3 - Neutral, 4, Moderately Agree, 5 - Strongly Agree. With this approach high response numbers indicate more job satisfaction. However, using the opposite scale would not make sense: 1 - Strongly Agree, 2 - Moderately Agree, 3 - Neutral, 4, Moderately Disagree, 5 - Strongly Disagree. With this opposite scale high numbers on a job satisfaction scale would indicate lower levels of job satisfaction - a very confusing situation. Avoid this situation, assign numbers so that higher numbers are associated with more of the construct being measured. Use appropriate item names. As described in the naming convention section, use moderate length names with different labels for each subscale. Use moderate length column names unique to each subscale. Imagine you have a survey with an 18-item commitment scale (Meyer, Allen, and Smith 1993) composed of three 6-item subscales: affective, normative, and continuance commitment. It would be a poor choice to prefix the labels of all 18 columns in your data with “commit” such that the names would be commit1, commit2, commit3, etc. The problem with this approach is that it fails to distinguish among the three subscales in naming convention; making it impossible to select the items for a single subscale using starts_with(). A better, but still poor choice for a naming convention would be use use a two letter prefix for the three scale such ac, nc, and cc. This would result in names for the columns like ac1, ac2, ac3, etc. This is an improvement because you could apparently (but likely not) select the columns using starts_with(“ac”). The problem with these short names is that there could be many columns in data set that start with “ac” beside the affective commitment items. You might want to select the affective commitment items using starts_with(“ac”); but you would get all the affective commitment item columns; but also all the columns measuring other variables that also start with “ac”. Therefore, it’s a good idea to use a moderate length unique prefix for column names. For example, you might use prefixes like affectcom, normcom, and contincom for the three subscales. This would create column names like affectcom1, affectcom2, affectcom3, etc. These column prefixes are unlikely to be duplicated in other places in your column name conventions making it easy to select those columns using a command like starts_with(“affectcom”). Indicate in the item name if the item is reversed keyed. Sometimes with Likert-type items, an item is reverse keyed. For example, on a job satisfaction scale, participants will typically respond to items that reflect job satisfaction using the scale: 1 - Strongly Disagree, 2 - Moderately Disagree, 3 - Neutral, 4, Moderately Agree, 5 - Strongly Agree. Higher numbers indicate more job satisfaction. Sometimes, however, some items will use the same 1 to 5 response scale but be worded in the opposite manner such as “I hate my job”. Responding with a 5 to this item would indicate high job dissatisfaction. But the columns for job satisfaction items should have high values indicate job satisfaction not job dissatifaction. Consequently, we flag the names of columns with reversed responses (i.e., reverse-key items) so that we know to treat those column differently later. Columns with reverse-keyed items need to be processed by a script so that the values are flipped and scored in the right direction. The procedure for doing so is outlined in the next point. Indicate in the item name the range for reverse-key items. If an item is reverse keyed, the process for the flipping the scores depends upon the range of a scale. Although 5-point scales are common, any number of points are possible. The process for correcting a reverse-key item depends upon: 1) the number of points on the scale, and 2) the range of the points on the scale. The reverse-key item correction process is different for an item that uses a 5-point scale ranging from 1 to 5 versus from 0 to 4. Both are 5-point scales but your correction process will be different. Therefore, for reverse-key items add a suffix at the end of each item name that indicates an item is reverse keyed and the range of the item. For example, if the third job satisfaction item was reversed keyed on scale using a 1 to 5 response format you might name the item: jobsat3_rev15. The suffix \"_rev15\" indicates the item is reverse keyed and the range of responses used on the item is 1 to 5. Be sure to set up your survey with this naming convention when you collect your data. If you collect items over multiple time points use a prefix with a short code to indicate the time followed by an underscore. For example, if you had a multi-item self-esteem scale you might call the column for the first time “t1_esteem1_rev15”. This indicate that you have for time 1 (t1), the first self-esteem item (esteem1) and that item is reverse keyed on a 1 to 5 scale. 4.5 Following the examples Below we present example scripts transforming raw data to analytic data for various study designs (experimental and survey). These examples illustrate the value of using the naming conventions outlined previously. Don’t just read the example - follow along with the projects by creating a separate script for each example. Resist the urge to cut and paste from this document - type the script yourself. When first learning iPhone/Mac software development, I did so by taking a course at Big Nerd Ranch - yes, that’s a real place. They advised in their material (and now book) the following: “We have learned that “going through the motions” is much more important than it sounds. Many times we will ask you to start typing in code before you understand it. We realize that you may feel like a trained monkey typing in a bunch of code that you do not fully grasp. But the best way to learn coding is to find and fix your typos. Far from being a drag, this basic debugging is where you really learn the ins and outs of the code. That is why we encourage you to type in the code yourself. You could just download it, but copying and pasting is not programming. We want better for you and your skills.\", p. xiv, (Keur and Hillegass 2020). This is excellent advice for a beginning statistician or data scientist as well. And as an aside: if you want to learn iPhone programming you can’t go wrong with the Big Nerd Ranch guide! As you work through this chapter, create your own new script for each example. In light of the above advice, avoid copying and pasting code - type it out; you will be the better for it. Getting started: The Class: R Studio in the Cloud Assignment The data should be in the assignment project automatically. Just start the assignment. For everyone in the class, that’s it. For those of you not in the class, and reading this work, see the two options below: R Studio Cloud, custom project Create a new Project using the web interface Upload all the example data files into the project. The data files needed are listed at the beginning of this chapter. The upload button can be found on the Files tab. R Studio Computer, custom project Create a folder on your computer for the example Place all the example data files in that folder. The data files needed are listed at the beginning of this chapter. Use the menu item File &gt; New Project… to start the project On the window that appears select “Existing Directory” On the next screen, press the “Browse” button and find/select the folder with your data Press the Create Project Button Regardless of whether your are working from the cloud, or locally, you should now have an R Studio project with your data files in it. We anticipate that many people will doubtless want to refer back to an encapsulated set of instructions for each design. Therefore the example for each design is written in a way that it stands alone. A consequence of this approach is that there is some redundancy in the code across examples. We see this a strength - because readers will see the commonalities across differ types of designs. As you make a script for each example: Recall the instruction from Chapter 1 about putting the date and your name in the script via comments. Recall the instruction from Chapter 1 about running library(tidyverse) before you type the rest of each script - this provides you with tidyverse autocomplete for the script. After you type each new block of code in an example, save your script. After you type each new block of code in an example, do two additional things: 1) Session Restart R, 2) Run your script using Source with Echo. 4.6 Entering data into spreadsheets The first example uses a data file data_ex_between.csv that corresponds to a fictitious example where we recorded the run times for a number of male and female participants. How did we create this data file? We used a spreadsheet to enter the data, as illustrated in Figure 4.3. Programs like Microsoft Excel and Google Sheets are good options for entering data. FIGURE 4.3: Spreadsheet entry of running data The key to using these types of programs is to save the data as a .csv file when you are done. CSV is short for Comma Separated Values. After entering the data in Figure 4.3 we saved it as data_ex_between.csv. There is no need to do so, but if you were to open this file in a text editor (such as TextEdit on a Mac or Notepad on Windows) you would see the information displayed in Figure 4.4. You can see there is one row per person and the columns are created by separating each values by a comma; hence, comma separated values. FIGURE 4.4: Text view of CSV data There are many ways to save data, but the CSV data is one of the better ones because it is a non-proprietary format. Some software, such as SPSS, uses a proprietary format (e.g., .sav for SPSS) this makes it challenging to access that data if you don’t have that (often expensive) software. One of our goals as scientists is to make it easy for others to audit our work - that allows science to be self-correcting. Therefore, choose an open format for your data like .csv. 4.7 Surveys: Single Occassion This section outlines a workflow appropriate for when you have cross-sectional single occasion survey data. The data corresponds to a design where the researcher has measured, age, sex, eye color, self-esteem, and job satisfaction. Two of these, self-esteem and job satisfaction, were measured with multi-item scales with reverse-keyed items. To Begin: Use the Files tab to confirm you have the data: data_item_scoring.csv Start a new script for this example. Don’t forget to start the script name with “script_”. # Date: YYYY-MM-DD # Name: your name here # Example: Single occasion survey # Load data library(tidyverse) my_missing_value_codes &lt;- c(&quot;-999&quot;, &quot;&quot;, &quot;NA&quot;) raw_data_survey &lt;- read_csv(file = &quot;data_item_scoring.csv&quot;, na = my_missing_value_codes) ## ## ── Column specification ──────────────────────────────────── ## cols( ## id = col_double(), ## age = col_double(), ## sex = col_character(), ## eye_color = col_character(), ## esteem1 = col_double(), ## esteem2 = col_double(), ## esteem3 = col_double(), ## esteem4 = col_double(), ## esteem5_rev15 = col_double(), ## jobsat1 = col_double(), ## jobsat2_rev15 = col_double(), ## jobsat3 = col_double(), ## jobsat4 = col_double(), ## jobsat5 = col_double() ## ) We load the initial data into a raw_data_survey but immediately make a copy we will work with called analytic_data_survey. It’s good to keep a copy of the raw data for reference if you encounter problems. analytic_data_survey &lt;- raw_data_survey Remove empty row and columns from your data using the remove_empty_cols() and remove_empty_rows(), respectively. As well, clean the names of your columns to ensure they conform to tidyverse naming conventions. library(janitor) ## ## Attaching package: &#39;janitor&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## chisq.test, fisher.test # Initial cleaning analytic_data_survey &lt;- analytic_data_survey %&gt;% remove_empty(&quot;rows&quot;) %&gt;% remove_empty(&quot;cols&quot;) %&gt;% clean_names() You can confirm the column names following our naming convention with the glimpse command - and see the data type for each column. glimpse(analytic_data_survey) ## Rows: 300 ## Columns: 14 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … ## $ age &lt;dbl&gt; 23, 22, 18, 23, 22, 17, 23, 22, 17,… ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,… ## $ eye_color &lt;chr&gt; &quot;blue&quot;, &quot;brown&quot;, &quot;hazel&quot;, &quot;blue&quot;, N… ## $ esteem1 &lt;dbl&gt; 3, 4, 4, 3, 3, 3, 3, 4, 4, 4, 3, 4,… ## $ esteem2 &lt;dbl&gt; 2, 3, 3, 2, 2, 3, 2, 3, 3, 3, 2, 2,… ## $ esteem3 &lt;dbl&gt; 4, 4, 4, 3, 4, 4, NA, 4, 4, 3, 4, 4… ## $ esteem4 &lt;dbl&gt; 3, 4, 4, 3, 4, 4, 4, 4, 3, 4, NA, 4… ## $ esteem5_rev15 &lt;dbl&gt; 2, 2, 2, 2, 2, NA, NA, 2, 2, 2, 3, … ## $ jobsat1 &lt;dbl&gt; 3, 5, 4, 3, 3, 3, 3, 5, 3, 3, 3, 4,… ## $ jobsat2_rev15 &lt;dbl&gt; 1, 1, 1, NA, 1, 1, 2, 1, 2, 2, 3, 1… ## $ jobsat3 &lt;dbl&gt; 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3… ## $ jobsat4 &lt;dbl&gt; NA, 5, 5, 4, 4, 4, 4, 5, NA, 4, NA,… ## $ jobsat5 &lt;dbl&gt; 5, NA, 5, 4, 5, 4, 4, 5, 5, 5, 4, N… 4.7.1 Creating factors Following initial cleaning, we identify categorical variables as factors. If you plan to conduct an ANOVA - it’s critical that all predictor variables are converted to factors. Inspect the glimpse() output - if you followed our data entry naming conventions, categorical variables should be of the type character. glimpse(analytic_data_survey) ## Rows: 300 ## Columns: 14 ## $ id &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … ## $ age &lt;dbl&gt; 23, 22, 18, 23, 22, 17, 23, 22, 17,… ## $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;,… ## $ eye_color &lt;chr&gt; &quot;blue&quot;, &quot;brown&quot;, &quot;hazel&quot;, &quot;blue&quot;, N… ## $ esteem1 &lt;dbl&gt; 3, 4, 4, 3, 3, 3, 3, 4, 4, 4, 3, 4,… ## $ esteem2 &lt;dbl&gt; 2, 3, 3, 2, 2, 3, 2, 3, 3, 3, 2, 2,… ## $ esteem3 &lt;dbl&gt; 4, 4, 4, 3, 4, 4, NA, 4, 4, 3, 4, 4… ## $ esteem4 &lt;dbl&gt; 3, 4, 4, 3, 4, 4, 4, 4, 3, 4, NA, 4… ## $ esteem5_rev15 &lt;dbl&gt; 2, 2, 2, 2, 2, NA, NA, 2, 2, 2, 3, … ## $ jobsat1 &lt;dbl&gt; 3, 5, 4, 3, 3, 3, 3, 5, 3, 3, 3, 4,… ## $ jobsat2_rev15 &lt;dbl&gt; 1, 1, 1, NA, 1, 1, 2, 1, 2, 2, 3, 1… ## $ jobsat3 &lt;dbl&gt; 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3… ## $ jobsat4 &lt;dbl&gt; NA, 5, 5, 4, 4, 4, 4, 5, NA, 4, NA,… ## $ jobsat5 &lt;dbl&gt; 5, NA, 5, 4, 5, 4, 4, 5, 5, 5, 4, N… We have two variables, sex and eye_color, that are categorical variable of type character (i.e., chr). The participant id column is categorical as well, but of type double (i.e., dbl) which is a numeric column. You can quickly convert all character columns to factors using the code below: analytic_data_survey &lt;- analytic_data_survey %&gt;% mutate(across(.cols = where(is.character), .fns = as_factor)) The participant identification number in the id column is a numeric column, so we have to handle that column on its own. analytic_data_survey &lt;- analytic_data_survey %&gt;% mutate(id = as_factor(id)) You can ensure all of these columns are now factors using the glimpse() command. glimpse(analytic_data_survey) ## Rows: 300 ## Columns: 14 ## $ id &lt;fct&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … ## $ age &lt;dbl&gt; 23, 22, 18, 23, 22, 17, 23, 22, 17,… ## $ sex &lt;fct&gt; male, female, male, female, male, f… ## $ eye_color &lt;fct&gt; blue, brown, hazel, blue, NA, hazel… ## $ esteem1 &lt;dbl&gt; 3, 4, 4, 3, 3, 3, 3, 4, 4, 4, 3, 4,… ## $ esteem2 &lt;dbl&gt; 2, 3, 3, 2, 2, 3, 2, 3, 3, 3, 2, 2,… ## $ esteem3 &lt;dbl&gt; 4, 4, 4, 3, 4, 4, NA, 4, 4, 3, 4, 4… ## $ esteem4 &lt;dbl&gt; 3, 4, 4, 3, 4, 4, 4, 4, 3, 4, NA, 4… ## $ esteem5_rev15 &lt;dbl&gt; 2, 2, 2, 2, 2, NA, NA, 2, 2, 2, 3, … ## $ jobsat1 &lt;dbl&gt; 3, 5, 4, 3, 3, 3, 3, 5, 3, 3, 3, 4,… ## $ jobsat2_rev15 &lt;dbl&gt; 1, 1, 1, NA, 1, 1, 2, 1, 2, 2, 3, 1… ## $ jobsat3 &lt;dbl&gt; 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3… ## $ jobsat4 &lt;dbl&gt; NA, 5, 5, 4, 4, 4, 4, 5, NA, 4, NA,… ## $ jobsat5 &lt;dbl&gt; 5, NA, 5, 4, 5, 4, 4, 5, 5, 5, 4, N… Inspect the output of the glimpse() command and make sure you have converted all categorical variables to factors - especially those you will use as predictors. Note: f you have factors like sex that have numeric data in the column (e.g, 1 and 2) instead of male/female you need to handle the situation differently. The preceding section, Experiment: Within N-way, illustrates how to handle this scenario. 4.7.2 Factor screening Inspect the levels of each factor carefully. Make sure the factor levels of each variable are correct. Examine spelling and look for additional unwanted levels. For example, you wouldn’t want to have the following levels for sex: male, mmale, female. Obviously, mmale is an incorrectly typed version of male. Scan all the factors in your data for erroneous factor levels. The code below displays the factor levels: analytic_data_survey %&gt;% select(where(is.factor)) %&gt;% summary() ## id sex eye_color ## 1 : 1 male :147 blue : 99 ## 2 : 1 female :149 brown: 98 ## 3 : 1 intersex: 2 hazel:100 ## 4 : 1 NA&#39;s : 2 NA&#39;s : 3 ## 5 : 1 ## 6 : 1 ## (Other):294 Also inspect the output of the above summary() command paying attention to the order of the levels in the factors. The order influences how text output and graphs are generated. In these data, the sex column has two levels: male and female in that order. Below we adjust the order of the sex variable because we want the x-axis of a future graph to display columns in the left to right order: female, male. analytic_data_survey &lt;- analytic_data_survey %&gt;% mutate(sex = fct_relevel(sex, &quot;intersex&quot;, &quot;female&quot;, &quot;male&quot;)) For eye color, we want a future graph to have the most common eye colors on the left so we reorder the factor levels: analytic_data_survey &lt;- analytic_data_survey %&gt;% mutate(eye_color = fct_infreq(eye_color)) You can see the new order of the factor levels with summary(): analytic_data_survey %&gt;% select(where(is.factor)) %&gt;% summary() ## id sex eye_color ## 1 : 1 intersex: 2 hazel:100 ## 2 : 1 female :149 blue : 99 ## 3 : 1 male :147 brown: 98 ## 4 : 1 NA&#39;s : 2 NA&#39;s : 3 ## 5 : 1 ## 6 : 1 ## (Other):294 4.7.3 Numeric screening For numeric variables, it’s important to find and remove impossible values. For example, in the context of this example you want to ensure none of the Likert responses are impossible (e.g., outside the 1- to 5-point rating scale) or clearly data entry errors. Because we have several numeric columns that we are screening, we use the skim() command from the skimr package. The skim() command quickly provides basic descriptive statistics. In the output for this command there are also several columns that begin with p: p0, p25, p50, p75, and p100 (p25 and p75 omitted in output due to space). These columns correspond to the 0th, 25th, 50th, 75th, and 100th percentiles, respectively. The minimum and maximum values for the data column are indicated under the p0 and p100 labels. The median is the 50th percentile (p50). The interquartile range is the range between p25 and p75. Start by examining the range of non-scale items. In this case it’s only age. Examine the output to see if any of the age values are unreasonable. As noted, in the output p0 and p100 indicate the 0th percentile and the 100th percentile; that is the minimum and maximum values for the variable. Check to make sure none of the age values are unreasonably low or high. If they are, you may need to check the original data source or replace them with missing values. library(skimr) analytic_data_survey %&gt;% select(age) %&gt;% skim() ## skim_variable n_missing mean sd p0 p50 p100 ## 1 age 3 20.52 2.05 17 20 24 With respect to the multi-item scales, it makes sense to look at sets of items rather than all of the items at once. This is because sometimes items from different scales use different response ranges. For example, one measure might use a response scale with a range from 1 to 5; whereas another measure might use a response scale with a range from 1 to 7. This is undesirable from a psychometric point of view, as discussed previously, but if it happens in your data - look at the scale items separately to make it easy to see out of range values. We begin by looking at the items in the first scale, self-esteem. Possible items responses for this scale range from 1 to 5; make sure all responses are in this range. If any values fall outside this range, you may need to check the original data source or replace them with missing values - as described previously. analytic_data_survey %&gt;% select(starts_with(&quot;esteem&quot;)) %&gt;% skim() ## skim_variable n_missing mean sd p0 p50 p100 ## 1 esteem1 24 3.39 0.54 3 3 5 ## 2 esteem2 28 2.35 0.48 2 2 3 ## 3 esteem3 31 3.96 0.37 3 4 5 ## 4 esteem4 15 3.54 0.50 3 4 4 ## 5 esteem5_rev15 35 2.22 0.47 1 2 3 Follow the same process for the job satisfaction items. Write that code on your own now. Possible item responses for the job satisfaction scale range from 1 to 5, make sure all responses are in this range. If any values fall outside this range, you may need to check the original data source or replace them with missing values - as described previously. analytic_data_survey %&gt;% select(starts_with(&quot;jobsat&quot;)) %&gt;% skim() ## skim_variable n_missing mean sd p0 p50 p100 ## 1 jobsat1 25 3.34 0.51 3 3 5 ## 2 jobsat2_rev15 27 1.51 0.61 1 1 3 ## 3 jobsat3 28 2.84 0.37 2 3 3 ## 4 jobsat4 35 4.29 0.70 3 4 5 ## 5 jobsat5 24 4.57 0.61 3 5 5 4.7.4 Scale scores For each person, scale scores involve averaging scores from several items to create an overall score. The first step in the creation of scales is correcting the values of any reverse-keyed items. 4.7.4.1 Reverse-key items The way you deal with reverse-keyed items depends on how you scored them. Imagine you had a 5-point scale. You could have scored the scale with the values 1, 2, 3, 4, and 5. Alternatively, you could have scored the scale with the values 0, 1, 2, 3, and 4. The mathematical approach you use to correcting reverse-keyed items depends upon whether the scale starts with 1 or 0. In this example, we scored the data using the value 1 to 5; so that is the approach illustrated here. See the extra information box for details on how to fixed reverse-keyed items when the scale begins with zero. In this data file all the reverse-keyed items were identified with the suffix \"_rev15\" in the column names. This suffix indicates the item was reverse keyed and that the original scale used the response points 1 to 5. We can see those items with the glimpse() command below. Notice that there are two reverse-keyed items - each on difference scales. analytic_data_survey %&gt;% select(ends_with(&quot;_rev15&quot;)) %&gt;% glimpse() ## Rows: 300 ## Columns: 2 ## $ esteem5_rev15 &lt;dbl&gt; 2, 2, 2, 2, 2, NA, NA, 2, 2, 2, 3, … ## $ jobsat2_rev15 &lt;dbl&gt; 1, 1, 1, NA, 1, 1, 2, 1, 2, 2, 3, 1… To correct a reverse-keyed item where the lowest possible rating is 1 (i.e, 1 on a 1 to 5 scale), we simply subtract all the scores from a value one more than the highest point possible on the scale (i.e., one more than 5). For example, if a 1 to 5 response scale was used we subtract each response from 6 to obtain the recoded value. Original value Math Recoded value 1 6 - 1 5 2 6 - 2 4 3 6 - 3 3 4 6 - 4 2 5 6 - 5 1 The code below: selects columns that end with \"_rev15\" (i.e., both esteem and jobsat scales) subtracts the values in those columns from 6 renames the columns by removing \"_rev15\" from the name because the reverse coding is complete analytic_data_survey &lt;- analytic_data_survey %&gt;% mutate(6 - across(.cols = ends_with(&quot;_rev15&quot;)) ) %&gt;% rename_with(.fn = str_remove, .cols = ends_with(&quot;_rev15&quot;), pattern = &quot;_rev15&quot;) You can use the glimpse() command to see the result of your work. If you compare these new values to those obtained from the previous glimpse() command you can see they have changed. Also notice the column names no longer indicate the items are reverse keyed. glimpse(analytic_data_survey) ## Rows: 300 ## Columns: 14 ## $ id &lt;fct&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, … ## $ age &lt;dbl&gt; 23, 22, 18, 23, 22, 17, 23, 22, 17, NA,… ## $ sex &lt;fct&gt; male, female, male, female, male, femal… ## $ eye_color &lt;fct&gt; blue, brown, hazel, blue, NA, hazel, bl… ## $ esteem1 &lt;dbl&gt; 3, 4, 4, 3, 3, 3, 3, 4, 4, 4, 3, 4, NA,… ## $ esteem2 &lt;dbl&gt; 2, 3, 3, 2, 2, 3, 2, 3, 3, 3, 2, 2, NA,… ## $ esteem3 &lt;dbl&gt; 4, 4, 4, 3, 4, 4, NA, 4, 4, 3, 4, 4, 4,… ## $ esteem4 &lt;dbl&gt; 3, 4, 4, 3, 4, 4, 4, 4, 3, 4, NA, 4, 3,… ## $ esteem5 &lt;dbl&gt; 4, 4, 4, 4, 4, NA, NA, 4, 4, 4, 3, 4, 4… ## $ jobsat1 &lt;dbl&gt; 3, 5, 4, 3, 3, 3, 3, 5, 3, 3, 3, 4, 4, … ## $ jobsat2 &lt;dbl&gt; 5, 5, 5, NA, 5, 5, 4, 5, 4, 4, 3, 5, 3,… ## $ jobsat3 &lt;dbl&gt; 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,… ## $ jobsat4 &lt;dbl&gt; NA, 5, 5, 4, 4, 4, 4, 5, NA, 4, NA, 5, … ## $ jobsat5 &lt;dbl&gt; 5, NA, 5, 4, 5, 4, 4, 5, 5, 5, 4, NA, 4… If your scale had used response options numbered 0 to 4 the math is different. For each item you would use subtract values from the highest possible point (i.e, 4) instead of one larger than the highest possible point. Original value Math Recoded value 0 4 - 0 4 1 4 - 1 3 2 4 - 2 2 3 4 - 3 1 4 4 - 4 0 Thus, the mutate command would instead be: mutate(4 - across(.cols = ends_with(\"_rev15\")) ) 4.7.4.2 Creating scores The process we use for creating scale scores deletes item-level data from analytic_data_survey. This is a desirable aspect of the process because it removes information that we are no longer interested in from our analytic data. That said, before we create scale score, we create a backup on the item-level data called analytic_data_survey_items. We will need to use this backup later to compute the reliability of the scales we are creating. analytic_data_survey_items &lt;- analytic_data_survey We want to make a self_esteem scale and plan to select items using starts_with(“esteem”). But prior to doing this we make sure the start_with() command only gives us the items we want - and not additional unwanted items. The output below confirms there are not problems associated with using starts_with(“esteem”). analytic_data_survey %&gt;% select(starts_with(&quot;esteem&quot;)) %&gt;% glimpse() ## Rows: 300 ## Columns: 5 ## $ esteem1 &lt;dbl&gt; 3, 4, 4, 3, 3, 3, 3, 4, 4, 4, 3, 4, NA, N… ## $ esteem2 &lt;dbl&gt; 2, 3, 3, 2, 2, 3, 2, 3, 3, 3, 2, 2, NA, 3… ## $ esteem3 &lt;dbl&gt; 4, 4, 4, 3, 4, 4, NA, 4, 4, 3, 4, 4, 4, N… ## $ esteem4 &lt;dbl&gt; 3, 4, 4, 3, 4, 4, 4, 4, 3, 4, NA, 4, 3, 3… ## $ esteem5 &lt;dbl&gt; 4, 4, 4, 4, 4, NA, NA, 4, 4, 4, 3, 4, 4, … Likewise, we want to make a job_sat scale and plan to select items using starts_with(“jobsat”). The code and output below using starts_with(“jobsat”) only returns the items we are interested in. analytic_data_survey %&gt;% select(starts_with(&quot;jobsat&quot;)) %&gt;% glimpse() ## Rows: 300 ## Columns: 5 ## $ jobsat1 &lt;dbl&gt; 3, 5, 4, 3, 3, 3, 3, 5, 3, 3, 3, 4, 4, 3,… ## $ jobsat2 &lt;dbl&gt; 5, 5, 5, NA, 5, 5, 4, 5, 4, 4, 3, 5, 3, 4… ## $ jobsat3 &lt;dbl&gt; 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2… ## $ jobsat4 &lt;dbl&gt; NA, 5, 5, 4, 4, 4, 4, 5, NA, 4, NA, 5, 4,… ## $ jobsat5 &lt;dbl&gt; 5, NA, 5, 4, 5, 4, 4, 5, 5, 5, 4, NA, 4, … We calculate the scale scores using the rowwise() command. The mean() command provides the mean of columns by default - not people. We use the rowwise() command in the code below to make the mean() command work across columns (within participants) rather than within columns. The mutate command calculates the scale score for each person. The c_across() command combined with the starts_with() command ensures the items we want averaged together are the items that are averaged together. Notice there is a separate mutate line for each scale. The ungroup() command turns off the rowwise() command. We end the code block by removing the item-level data from the data set. Important: Take note of how we name the scale variables (e.g., self_esteem, job_sat). We use a slightly different convention than our items. That is, these scale labels were picked so that they would not be selected by a starts_with(“esteem”) or starts_with(“jobsat”). Why - because we later use those commands to remove the item-level data. We would want the command designed to remove the item-level data to also remove the scale we just calculated! This example illustrates how carefully you need to think about your naming conventions. analytic_data_survey &lt;- analytic_data_survey %&gt;% rowwise() %&gt;% mutate(self_esteem = mean(c_across(starts_with(&quot;esteem&quot;)), na.rm = TRUE)) %&gt;% mutate(job_sat = mean(c_across(starts_with(&quot;jobsat&quot;)), na.rm = TRUE)) %&gt;% ungroup() %&gt;% select(-starts_with(&quot;esteem&quot;)) %&gt;% select(-starts_with(&quot;jobsat&quot;)) We can see our data now has the self_esteem column, a job_sat column, and that all of the item-level data has been removed. glimpse(analytic_data_survey) ## Rows: 300 ## Columns: 6 ## $ id &lt;fct&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12… ## $ age &lt;dbl&gt; 23, 22, 18, 23, 22, 17, 23, 22, 17, N… ## $ sex &lt;fct&gt; male, female, male, female, male, fem… ## $ eye_color &lt;fct&gt; blue, brown, hazel, blue, NA, hazel, … ## $ self_esteem &lt;dbl&gt; 3.200, 3.800, 3.800, 3.000, 3.400, 3.… ## $ job_sat &lt;dbl&gt; 4.00, 5.00, 4.40, 3.50, 4.00, 3.80, 3… You now have two data sets analytic_data_survey and analytic_data_survey_items. You can calculate descriptive statistics, correlations and most analyses using the analytic_data_survey. To obtain the reliability of the scales you just created though you will need to use the analytic_data_survey_items. Both sets of data are ready for analysis. 4.8 Basic descriptive statistics Regardless of the design of the study, most researchers want to see descriptive statistics for the variables in their study. We offer three approaches for obtaining descriptive statistics below. For convenience we use the recent data set analytic_data_occasions. But recognize the commands below can be used with all the analytic data sets we created for the various designs. 4.8.1 skim() One approach is the skim() command from the skimr package. The skim() command quickly provides the basic descriptive statistics. In the output for this command there are also several columns that begin with p: p0, p25, p50, p75, and p100 (p25 and p75 are omitted in output due to space). These columns correspond to the 0th, 25th, 50th, 75th, and 100th percentiles, respectively. The minimum and maximum values for the data column are indicated under the p0 and p100 labels. The median is the 50th percentile (p50). The interquartile range is the range between p25 and p75. Notice that we run this command on the “wide” version of the data (analytic_data_occasions) rather than tidy version of the data (analytic_occasion_tidy). library(skimr) skim(analytic_data_survey) ## skim_variable n_missing mean sd p0 p50 p100 ## 1 age 3 20.52 2.05 17.0 20.0 24.00 ## 2 self_esteem 0 3.40 0.32 2.5 3.4 4.25 ## 3 job_sat 0 3.91 0.43 2.0 4.0 5.00 4.8.2 apa.cor.table() Another approach is the apa.cor.table() command from the apaTables package. This quickly provides the basic descriptive statistics as well as correlations among variable. As well, it will even create a Word document with this information, see Figure 4.5. Notice that we run this command on the “wide” version of the data (analytic_data_occasions) rather than tidy version of the data (analytic_occasion_tidy). library(apaTables) analytic_data_survey %&gt;% select(where(is.numeric)) %&gt;% apa.cor.table(filename = &quot;apa_descriptives.doc&quot;) FIGURE 4.5: Word document created by apa.cor.table 4.8.3 tidyverse A final approach uses tidyverse commands. This approach is oddly long - and we won’t describe how it works in detail. But, based on the information in the previous chapter you should be able to work out how this code works. Even though this code is long - it provide the ultimate in flexibility. If a new statistic is developed that you want to use, you can simply include the command for it in the desired_descriptives list and it will be included in your table. Notice that we run this command on the “wide” version of the data (analytic_data_occasions) rather than tidy version of the data (analytic_occasion_tidy). library(tidyverse) # HMisc package must be installed. # Library command not needed for HMisc package. desired_descriptives &lt;- list( mean = ~mean(.x, na.rm = TRUE), CI95_LL = ~Hmisc::smean.cl.normal(.x)[2], CI95_UL = ~Hmisc::smean.cl.normal(.x)[3], sd = ~sd(.x, na.rm = TRUE), min = ~min(.x, na.rm = TRUE), max = ~max(.x, na.rm = TRUE), n = ~sum(!is.na(.x)) ) row_sum &lt;- analytic_data_survey %&gt;% summarise(across(.cols = where(is.numeric), .fns = desired_descriptives, .names = &quot;{col}___{fn}&quot;)) long_summary &lt;- row_sum %&gt;% pivot_longer(cols = everything(), names_to = c(&quot;var&quot;, &quot;stat&quot;), names_sep = c(&quot;___&quot;), values_to = &quot;value&quot;) summary_table &lt;- long_summary %&gt;% pivot_wider(names_from = stat, values_from = value) # round to 3 decimals summary_table_rounded &lt;- summary_table %&gt;% mutate(across(.cols = where(is.numeric), .fns= round, digits = 3)) %&gt;% as.data.frame() print(summary_table_rounded) ## var mean CI95_LL CI95_UL sd min max n ## 1 age 20.522 20.288 20.756 2.048 17.0 24.00 297 ## 2 self_esteem 3.403 3.366 3.440 0.324 2.5 4.25 300 ## 3 job_sat 3.905 3.856 3.955 0.435 2.0 5.00 300 4.8.4 Cronbach’s alpha If you want Cronbach’s alpha to estimate the reliability of the scale, you can use the alpha command from the psych package with the code below. Note we have to use the item-level data we previously created a copy of called analytic_data_survey_items. The glimpse() command illustrates this data set has all the original items (after reverse-key coding has been fixed). analytic_data_survey_items %&gt;% glimpse() ## Rows: 300 ## Columns: 14 ## $ id &lt;fct&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, … ## $ age &lt;dbl&gt; 23, 22, 18, 23, 22, 17, 23, 22, 17, NA,… ## $ sex &lt;fct&gt; male, female, male, female, male, femal… ## $ eye_color &lt;fct&gt; blue, brown, hazel, blue, NA, hazel, bl… ## $ esteem1 &lt;dbl&gt; 3, 4, 4, 3, 3, 3, 3, 4, 4, 4, 3, 4, NA,… ## $ esteem2 &lt;dbl&gt; 2, 3, 3, 2, 2, 3, 2, 3, 3, 3, 2, 2, NA,… ## $ esteem3 &lt;dbl&gt; 4, 4, 4, 3, 4, 4, NA, 4, 4, 3, 4, 4, 4,… ## $ esteem4 &lt;dbl&gt; 3, 4, 4, 3, 4, 4, 4, 4, 3, 4, NA, 4, 3,… ## $ esteem5 &lt;dbl&gt; 4, 4, 4, 4, 4, NA, NA, 4, 4, 4, 3, 4, 4… ## $ jobsat1 &lt;dbl&gt; 3, 5, 4, 3, 3, 3, 3, 5, 3, 3, 3, 4, 4, … ## $ jobsat2 &lt;dbl&gt; 5, 5, 5, NA, 5, 5, 4, 5, 4, 4, 3, 5, 3,… ## $ jobsat3 &lt;dbl&gt; 3, NA, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,… ## $ jobsat4 &lt;dbl&gt; NA, 5, 5, 4, 4, 4, 4, 5, NA, 4, NA, 5, … ## $ jobsat5 &lt;dbl&gt; 5, NA, 5, 4, 5, 4, 4, 5, 5, 5, 4, NA, 4… We calculated reliability using psych::alpha() command. Cronbach’s alpha is labeled “raw alpha” in the output. Cronbach’s alpha is an estimate of the proportion of variability in observed scores that is due to actual differences among participants (rather than measurement error). Remember, never use library(psych), it will break the tidyverse packages. Instead, precede all psych package commands with psych:: as we do below with psych::alpha(). rxx_alpha &lt;- analytic_data_survey_items %&gt;% select(starts_with(&quot;esteem&quot;)) %&gt;% psych::alpha() print(rxx_alpha$total) ## raw_alpha std.alpha G6(smc) average_r S/N ase mean ## 0.6622 0.6634 0.6173 0.2827 1.97 0.03035 3.403 ## sd median_r ## 0.3239 0.2927 References "],["references.html", "References", " References "]]
